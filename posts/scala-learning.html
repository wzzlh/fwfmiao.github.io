<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="msvalidate.01" content="B3C8AB35B1F97A3EBC4244FFFA656AE9">
  <meta name="yandex-verification" content="DT5rdVpWuLkbg2sACQp0zsF3Fv8wTb-HPYijYJprwD8">
  <meta name="baidu-site-verification" content="yBSgXL4Z57vA68tQ">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"liufengyu.cn","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":true,"nav":{"disqus":{"text":"Load Disqus","order":-1}},"activeClass":"disqus"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Scala简介Scala是一门类Java的多范式语言，它整合了面向对象编程和函数式编程的最佳特性。具体来讲：  Scala运行于Java虚拟机（JVM）之上，并且兼容现有的Java程序，可以与Java类进行互操作，包括调用Java方法，创建Java对象，继承Java类和实现Java接口。 Scala是一门纯粹的面向对象的语言。在Scala语言中，每个值都是对象，每个操作都是方法调用。对象的数据类型">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala学习指南">
<meta property="og:url" content="https://liufengyu.cn/posts/scala-learning.html">
<meta property="og:site_name" content="飞鱼塘">
<meta property="og:description" content="Scala简介Scala是一门类Java的多范式语言，它整合了面向对象编程和函数式编程的最佳特性。具体来讲：  Scala运行于Java虚拟机（JVM）之上，并且兼容现有的Java程序，可以与Java类进行互操作，包括调用Java方法，创建Java对象，继承Java类和实现Java接口。 Scala是一门纯粹的面向对象的语言。在Scala语言中，每个值都是对象，每个操作都是方法调用。对象的数据类型">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://liufengyu.cn/posts/jdk-install/01.jpg">
<meta property="og:image" content="https://liufengyu.cn/posts/jdk-install/02.jpg">
<meta property="og:image" content="https://liufengyu.cn/posts/scala-learning/01.png">
<meta property="og:image" content="https://liufengyu.cn/posts/scala-learning/02.png">
<meta property="og:image" content="https://liufengyu.cn/posts/scala-learning/image-20191216095217933.png">
<meta property="og:image" content="https://liufengyu.cn/posts/scala-learning/image-20191216095332315.png">
<meta property="og:image" content="https://liufengyu.cn/posts/scala-learning/image-20191216100052821.png">
<meta property="og:image" content="https://liufengyu.cn/posts/scala-learning/image-20191216100115309.png">
<meta property="og:image" content="https://liufengyu.cn/posts/scala-learning/image-20191216103846484.png">
<meta property="og:image" content="https://liufengyu.cn/posts/scala-learning/image-20191216103918550.png">
<meta property="article:published_time" content="2019-09-04T11:14:21.000Z">
<meta property="article:modified_time" content="2020-08-09T08:05:48.976Z">
<meta property="article:author" content="飞木鱼">
<meta property="article:tag" content="Scala">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://liufengyu.cn/posts/jdk-install/01.jpg">

<link rel="canonical" href="https://liufengyu.cn/posts/scala-learning.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Scala学习指南 | 飞鱼塘</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">飞鱼塘</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">飞木鱼的个人博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">16</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">1</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://liufengyu.cn/posts/scala-learning.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="飞木鱼">
      <meta itemprop="description" content="整理一些值得留意的文章">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞鱼塘">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Scala学习指南
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-04 19:14:21" itemprop="dateCreated datePublished" datetime="2019-09-04T19:14:21+08:00">2019-09-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-09 16:05:48" itemprop="dateModified" datetime="2020-08-09T16:05:48+08:00">2020-08-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/posts/scala-learning.html#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/posts/scala-learning.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>33 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Scala简介"><a href="#Scala简介" class="headerlink" title="Scala简介"></a>Scala简介</h1><p>Scala是一门类Java的多范式语言，它整合了面向对象编程和函数式编程的最佳特性。具体来讲：</p>
<ul>
<li>Scala运行于Java虚拟机（JVM）之上，并且兼容现有的Java程序，可以与Java类进行互操作，包括调用Java方法，创建Java对象，继承Java类和实现Java接口。</li>
<li>Scala是一门纯粹的面向对象的语言。在Scala语言中，每个值都是对象，每个操作都是方法调用。对象的数据类型以及行为由类和特质描述。类抽象机制的扩展有两种途径，一种途径是子类继承，另一种途径是灵活的混入机制，这两种途径能避免多重继承的种种问题</li>
<li>Scala也是一门函数式语言。在Scala语言中，每个函数都是一个值，并且和其他类型（如整数、字符串等）的值处于同一地位。Scala提供了轻量级的语法用以定义匿名函数，支持高阶函数，允许嵌套多层函数，并支持柯里化</li>
</ul>
<h1 id="Scala安装"><a href="#Scala安装" class="headerlink" title="Scala安装"></a>Scala安装</h1><p>Scala运行在Java虚拟机（JVM）之上，因此只要安装有相应的Java虚拟机，所有的操作系统都可以运行Scala程序，包括Window、Linux、Unix、Mac OS等。</p>
<h2 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>首先打开JDK的<span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmV0d29yay9qYXZhL2phdmFzZS9kb3dubG9hZHMvaW5kZXguaHRtbA==">下载页面<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="jdk-install/01.jpg" alt="JDK"></p>
<p>这里我们选择的是Java SE Development Kit 8u191进行下载使用</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下载完毕后，使用下面的命令解压到相应的目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf .&#x2F;jdk-8u191-linux-x64.tar.gz -C &#x2F;opt</span><br></pre></td></tr></table></figure>

<p>编辑.bashrc文件，将下面的文本添加进环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#add Java environment</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;opt&#x2F;jdk1.8.0_201</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib</span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<p><img data-src="jdk-install/02.jpg" alt="JAVA版本查看"></p>
<p>然后运行下面的命令，查看JDK是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<h3 id="JDK没有JRE"><a href="#JDK没有JRE" class="headerlink" title="JDK没有JRE"></a>JDK没有JRE</h3><p>新版本的JDK（9,10,11,10）没有JRE，可以使用下面的命令，生成JRE模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</span><br></pre></td></tr></table></figure>

<h2 id="Scala安装-1"><a href="#Scala安装-1" class="headerlink" title="Scala安装"></a>Scala安装</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2NhbGEtbGFuZy5vcmcvZG93bmxvYWQvMi4xMS4xMi5odG1s">https://www.scala-lang.org/download/2.11.12.html<i class="fa fa-external-link-alt"></i></span></p>
<p>下载2.11版本的scala</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><h4 id="win"><a href="#win" class="headerlink" title="win"></a>win</h4><p>双击下一步下一步下一步下一步下一步完成</p>
<h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><p>解压到<code>/opt</code>目录下，配置好环境变量即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># SCALA</span><br><span class="line">export SCALA_HOME&#x3D;&#x2F;opt&#x2F;scala-2.12.9</span><br><span class="line">export PATH&#x3D;$&#123;SCALA_HOME&#125;&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<h1 id="Scala基础"><a href="#Scala基础" class="headerlink" title="Scala基础"></a>Scala基础</h1><h2 id="基础数据类型和变量"><a href="#基础数据类型和变量" class="headerlink" title="基础数据类型和变量"></a>基础数据类型和变量</h2><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><p>Scala的数据类型包括：Byte、Char、Short、Int、Long、Float、Double和Boolean（注意首字母大写）</p>
<p>和Java不同的是，在Scala中，这些类型都是“类”，并且都是包scala的成员，比如，Int的全名是scala.Int。对于字符串，Scala用java.lang.String类来表示字符串</p>
<table>
<thead>
<tr>
<th>值类型</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>8位有符号补码整数。数值区间为 -128 到 127 （-$$2^{7}$$~$$2^{7}-1$$）</td>
</tr>
<tr>
<td>Short</td>
<td>16位有符号补码整数。数值区间为 -32768 到 32767（-$$2^{15}$$~$$2^{15}-1$$）</td>
</tr>
<tr>
<td>Int</td>
<td>32位有符号补码整数。数值区间为（-$$2^{31}$$~$$2^{31}-1$$）</td>
</tr>
<tr>
<td>Long</td>
<td>64位有符号补码整数。数值区间为（-$$2^{63}$$~$$2^{63}-1$$）</td>
</tr>
<tr>
<td>Float</td>
<td>32 位, IEEE 754 标准的单精度浮点数</td>
</tr>
<tr>
<td>Double</td>
<td>64 位 IEEE 754 标准的双精度浮点数</td>
</tr>
<tr>
<td>Char</td>
<td>16位无符号Unicode字符, 区间值为 U+0000 到 U+FFFF（0~$$2^{16}-1$$）</td>
</tr>
<tr>
<td>String</td>
<td>字符序列</td>
</tr>
<tr>
<td>Boolean</td>
<td>true或false</td>
</tr>
</tbody></table>
<h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> i = <span class="number">123</span>            <span class="comment">//123就是整数字面量</span></span><br><span class="line"><span class="keyword">val</span> i = <span class="number">3.14</span>           <span class="comment">//3.14就是浮点数字面量</span></span><br><span class="line"><span class="keyword">val</span> i = <span class="literal">true</span>           <span class="comment">//true就是布尔型字面量</span></span><br><span class="line"><span class="keyword">val</span> i = &#x27;<span class="type">A</span>&#x27;            <span class="comment">//&#x27;A&#x27;就是字符字面量</span></span><br><span class="line"><span class="keyword">val</span> i = “<span class="type">Hello</span>”        <span class="comment">//“Hello”就是字符串字面量</span></span><br></pre></td></tr></table></figure>

<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>算术运算符：加(+)、减(-) 、乘(*) 、除(/) 、余数(%)；</p>
<p>关系运算符：大于(&gt;)、小于(&lt;)、等于(==)、不等于(!=)、大于等于(&gt;=)、小于等于(&lt;=)</p>
<p>逻辑运算符：逻辑与(&amp;&amp;)、逻辑或(||)、逻辑非(!)；</p>
<p>位运算符：按位与(&amp;)、按位或(|)、按位异或(^)、按位取反(~)</p>
<p>赋值运算符：=及其与其它运算符结合的扩展赋值运算符，例如+=、%=</p>
<p>操作符优先级：算术运算符 &gt; 关系运算符 &gt; 逻辑运算符 &gt; 赋值运算符</p>
<p>在Scala中，操作符就是方法</p>
<p>例如，5 + 3和(5).+(3)是等价的</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> sum1 = <span class="number">5</span> + <span class="number">3</span>         <span class="comment">//实际上调用了 (5).+(3)</span></span><br><span class="line">sum1: <span class="type">Int</span> = <span class="number">8</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> sum2 = (<span class="number">5</span>).+(<span class="number">3</span>)     <span class="comment">//可以发现，写成方法调用的形式，和上面得到相同的结果</span></span><br><span class="line">sum2: <span class="type">Int</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h4 id="富包装类"><a href="#富包装类" class="headerlink" title="富包装类"></a>富包装类</h4><p>对于基本数据类型，除了以上提到的各种操作符外，Scala还提供了许多常用运算的方法，只是这些方法不是在基本类里面定义，而是被封装到一个对应的富包装类中</p>
<p>每个基本类型都有一个对应的富包装类，例如Int有一个RichInt类、String有一个RichString类，这些类位于包scala.runtime中</p>
<p>当对一个基本数据类型的对象调用其富包装类提供的方法，Scala会自动通过隐式转换将该对象转换为对应的富包装类型，然后再调用相应的方法。例如：<code>3 max 5</code></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Scala有两种类型的变量：</p>
<ul>
<li><p>val：是不可变的，在声明时就必须被初始化，而且初始化以后就不能再赋值</p>
</li>
<li><p>var：是可变的，声明的时候需要进行初始化，初始化以后还可以再次对其赋值</p>
</li>
</ul>
<p>基本语法：</p>
<p>val  变量名:数据类型 = 初始值</p>
<p>var  变量名:数据类型 = 初始值</p>
<p>类型推断机制（type inference）：根据初始值自动推断变量的类型，使得定义变量时可以省略具体的数据类型及其前面的冒号</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> myStr = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">myStr: <span class="type">String</span> = <span class="type">Hello</span> <span class="type">World</span>!</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以显式声明变量的类型：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> myStr2 : <span class="type">String</span> = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">myStr2: <span class="type">String</span> = <span class="type">Hello</span> <span class="type">World</span>!</span><br><span class="line">scala&gt; println(myStr)</span><br><span class="line"><span class="type">Hello</span> <span class="type">World</span>!</span><br></pre></td></tr></table></figure>

<p>myStr是val变量，因此，一旦初始化以后，就不能再次赋值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; myStr = <span class="string">&quot;Hello Scala!&quot;</span></span><br><span class="line">&lt;console&gt;:<span class="number">27</span>: error: reassignment to <span class="keyword">val</span></span><br><span class="line">          myStr = <span class="string">&quot;Hello Scala!&quot;</span></span><br><span class="line">                ^</span><br></pre></td></tr></table></figure>

<p>var变量初始化以后，可以再次赋值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> myPrice : <span class="type">Double</span> = <span class="number">9.9</span></span><br><span class="line">myPrice: <span class="type">Double</span> = <span class="number">9.9</span></span><br><span class="line"></span><br><span class="line">scala&gt; myPrice = <span class="number">10.6</span></span><br><span class="line">myPrice: <span class="type">Double</span> = <span class="number">10.6</span></span><br></pre></td></tr></table></figure>

<p>注意：在REPL环境下，可以重复使用同一个变量名来定义变量，而且变量前的修饰符和其类型都可以不一致，REPL会以最新的一个定义为准</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> a = <span class="string">&quot;Xiamen University&quot;</span></span><br><span class="line">a: <span class="type">String</span> = <span class="type">Xiamen</span> <span class="type">University</span></span><br><span class="line">scala&gt; <span class="keyword">var</span> a = <span class="number">50</span></span><br><span class="line">a: <span class="type">Int</span> = <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="控制台输入输出语句"><a href="#控制台输入输出语句" class="headerlink" title="控制台输入输出语句"></a>控制台输入输出语句</h3><p>从控制台读入数据方法：readInt、readDouble、readByte、readShort、readFloat、readLong、readChar readBoolean及readLine，分别对应9种基本数据类型，其中前8种方法没有参数，readLine可以不提供参数，也可以带一个字符串参数的提示</p>
<p>所有这些函数都属于对象scala.io.StdIn的方法，使用前必须导入，或者直接用全称进行调用</p>
<p>从控制台读入数据方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> io.<span class="type">StdIn</span>._</span><br><span class="line"><span class="keyword">import</span> io.<span class="type">StdIn</span>._</span><br><span class="line">scala&gt; <span class="keyword">var</span> i=readInt()</span><br><span class="line"><span class="number">54</span></span><br><span class="line">i: <span class="type">Int</span> = <span class="number">54</span></span><br><span class="line">scala&gt; <span class="keyword">var</span> f=readFloat</span><br><span class="line"><span class="number">1.618</span></span><br><span class="line">f: <span class="type">Float</span> = <span class="number">1.618</span></span><br><span class="line">scala&gt; <span class="keyword">var</span> b=readBoolean</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">b: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">scala&gt; <span class="keyword">var</span> str=readLine(<span class="string">&quot;please input your name:&quot;</span>)</span><br><span class="line">please input your name:<span class="type">Li</span> <span class="type">Lei</span></span><br><span class="line">str: <span class="type">String</span> = <span class="type">Li</span> <span class="type">Lei</span></span><br></pre></td></tr></table></figure>

<p>向控制台输出信息方法：</p>
<ul>
<li>print()和println()，可以直接输出字符串或者其它数据类型，其中println在末尾自动换行。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> i=<span class="number">345</span></span><br><span class="line">i: <span class="type">Int</span> = <span class="number">345</span></span><br><span class="line">scala&gt; print(<span class="string">&quot;i=&quot;</span>);print(i) </span><br><span class="line"><span class="comment">//两条语句位于同一行，不能省略中间的分号</span></span><br><span class="line">i=<span class="number">345</span></span><br><span class="line">scala&gt; println(<span class="string">&quot;hello&quot;</span>);println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>

<ul>
<li>C语言风格格式化字符串的printf()函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> i = <span class="number">34</span></span><br><span class="line">i: <span class="type">Int</span> = <span class="number">34</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> f=<span class="number">56.5</span></span><br><span class="line">f: <span class="type">Double</span> = <span class="number">56.5</span></span><br><span class="line">scala&gt; printf(<span class="string">&quot;I am %d years old and weight %.1f Kg.&quot;</span>,<span class="string">&quot;Li Lie&quot;</span>,i,f)</span><br><span class="line"><span class="type">I</span> am <span class="number">34</span> years old and weight <span class="number">56.5</span> <span class="type">Kg</span>.</span><br></pre></td></tr></table></figure>

<p>print()、println()和printf() 都在对象Predef中定义，该对象默认情况下被所有Scala程序引用，因此可以直接使用Predef对象提供的方法，而无需使用scala.Predef.的形式。</p>
<p>s字符串和f字符串：Scala提供的字符串插值机制，以方便在字符串字面量中直接嵌入变量的值。</p>
<p>基本语法：s “ …$变量名… “ 或 f” …$变量名%格式化字符…”</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> i=<span class="number">10</span></span><br><span class="line">i: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> f=<span class="number">3.5</span></span><br><span class="line">f: <span class="type">Double</span> = <span class="number">3.5452</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> s=<span class="string">&quot;hello&quot;</span></span><br><span class="line">s: <span class="type">String</span> = hello</span><br><span class="line">scala&gt; println(<span class="string">s&quot;<span class="subst">$s</span>:i=<span class="subst">$i</span>,f=<span class="subst">$f</span>&quot;</span>)    <span class="comment">//s插值字符串</span></span><br><span class="line">hello:i=<span class="number">10</span>,f=<span class="number">3.5452</span></span><br><span class="line">scala&gt; println(<span class="string">f&quot;<span class="subst">$s</span>:i=<span class="subst">$i</span>%-4d,f=<span class="subst">$f</span>%.1f&quot;</span>)   <span class="comment">//f插值字符串</span></span><br><span class="line">hello:i=<span class="number">10</span>  ,f=<span class="number">3.5</span></span><br></pre></td></tr></table></figure>

<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p>Scala需要使用java.io.PrintWriter实现把数据写入到文件，PrintWriter类提供了print和println两个写方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> java.io.<span class="type">PrintWriter</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> outputFile = <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="string">&quot;test.txt&quot;</span>)</span><br><span class="line">scala&gt; outputFile.println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">scala&gt; outputFile.print(<span class="string">&quot;Spark is good&quot;</span>)</span><br><span class="line">scala&gt; outputFile.close()</span><br></pre></td></tr></table></figure>

<p>PrintWriter里路径可以是直接路径，也可以是相对路径</p>
<h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>可以使用scala.io.Source的getLines方法实现对文件中所有行的读取</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> file = <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="string">&quot;output.txt&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> lines = file.getLines()</span><br><span class="line"><span class="keyword">for</span> (line &lt;- lines) println(line)</span><br></pre></td></tr></table></figure>

<h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><h3 id="if条件表达式"><a href="#if条件表达式" class="headerlink" title="if条件表达式"></a>if条件表达式</h3><p>基本语法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式) &#123;</span><br><span class="line">    语句块<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    语句块<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val x &#x3D; 6</span><br><span class="line">if (x &gt; 0) &#123;</span><br><span class="line">  println(&quot;This is a positive number&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  println(&quot;This is not a positive number&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  println(<span class="string">&quot;This is a positive number&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">  println(<span class="string">&quot;This is a zero&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  println(<span class="string">&quot;This is a negative number&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点与Java不同的是，Scala中的if表达式的值可以赋值给变量</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">6</span></span><br><span class="line"><span class="keyword">val</span> a = <span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>相当于c或Java里的三元操作符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &gt; <span class="number">0</span> ? <span class="number">1</span>: -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>基本语法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (表达式)&#123;</span><br><span class="line">        循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">        循环体</span><br><span class="line">&#125;<span class="keyword">while</span> (表达式)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">9</span></span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  i -= <span class="number">1</span></span><br><span class="line">  printf(<span class="string">&quot;i is %d\n&quot;</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">  i += <span class="number">1</span></span><br><span class="line">  println(i)</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>基本语法 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (变量 &lt;- 表达式) &#123;语句块&#125;</span><br></pre></td></tr></table></figure>

<p>其中，“变量&lt;-表达式”被称为“生成器（generator）”</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">5</span>) println(i)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">5</span> by <span class="number">2</span>) println(i)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>“守卫(guard)”的表达式：过滤出一些满足条件的结果。基本语法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (变量 &lt;- 表达式 <span class="keyword">if</span> 条件表达式) 语句块</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">5</span> <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>) println(i)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>Scala也支持“多个生成器”的情形，可以用分号把它们隔开，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">1</span> to <span class="number">2</span>; j &lt;- <span class="number">1</span> to <span class="number">5</span>) println(<span class="string">f&quot;<span class="subst">$i</span>,<span class="subst">$j</span>&quot;</span>)</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span></span><br><span class="line"><span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="number">1</span>,<span class="number">3</span></span><br><span class="line"><span class="number">1</span>,<span class="number">4</span></span><br><span class="line"><span class="number">1</span>,<span class="number">5</span></span><br><span class="line"><span class="number">2</span>,<span class="number">1</span></span><br><span class="line"><span class="number">2</span>,<span class="number">2</span></span><br><span class="line"><span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="number">2</span>,<span class="number">4</span></span><br><span class="line"><span class="number">2</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>for推导式：for结构可以在每次执行的时候创造一个值，然后将包含了所有产生值的集合作为for循环表达式的结果返回，集合的类型由生成器中的集合类型确定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (变量 &lt;- 表达式) yield &#123;语句块&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> r=<span class="keyword">for</span> (i &lt;- <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">yield</span> &#123; println(i); i&#125;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">r: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">2</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>Scala不支持Java中的“受检查异常”(checked exception)，将所有异常都当作“不受检异常”（或称为运行时异常）</p>
<p>Scala仍使用try-catch结构来捕获异常</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.<span class="type">FileReader</span> </span><br><span class="line"><span class="keyword">import</span> java.io.<span class="type">FileNotFoundException</span> </span><br><span class="line"><span class="keyword">import</span> java.io.<span class="type">IOException</span> </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  <span class="keyword">val</span> f = <span class="keyword">new</span> <span class="type">FileReader</span>(<span class="string">&quot;input.txt&quot;</span>) </span><br><span class="line">    <span class="comment">// 文件操作 </span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123; </span><br><span class="line">  <span class="keyword">case</span> ex: <span class="type">FileNotFoundException</span> =&gt; </span><br><span class="line">    <span class="comment">// 文件不存在时的操作 </span></span><br><span class="line">  <span class="keyword">case</span> ex: <span class="type">IOException</span> =&gt; </span><br><span class="line">   <span class="comment">// 发生I/O错误时的操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">  file.close() <span class="comment">// 确保关闭文件 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>受检查异常和不受检查异常的区别：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdGp1ZHpqL3AvNzA1Mzk4MC5odG1s">https://www.cnblogs.com/tjudzj/p/7053980.html<i class="fa fa-external-link-alt"></i></span></p>
<p>异常，开发者之间一直存在着争议，毕竟两类异常都各有优缺点。受检异常的特点在于它强制要求开发人员在代码中进行显式的声明和捕获，否则就会产生编译错误。这种限制从好的方面来说，可以防止开发人员意外地忽略某些出错的情况，因为编译器不允许出现未被处理的受检异常；从不好的方面来说，受检异常对程序中的设计提出了更高的要求。不恰当地使用受检异常，会使代码中充斥着大量没有实际作用、只是为了通过编译而添加的代码。而非受检异常的特点是，如果不捕获异常，不会产生编译错误，异常会在运行时刻才被抛出。</p>
<p>非受检异常的好处是可以去掉一些不需要的异常处理代码，而不好之处是开发人员可能忽略某些应该处理的异常。一个典型的例子是把字符串转换成数字时会发生java.lang.NumberFormatException异常，忽略该异常可能导致一个错误的输入就造成整个程序退出。</p>
<p>目前的主流意见是，最好优先使用非受检异常。</p>
<h3 id="对循环的控制"><a href="#对循环的控制" class="headerlink" title="对循环的控制"></a>对循环的控制</h3><p>为了提前终止整个循环或者跳到下一个循环，Scala没有break和continue关键字</p>
<p>Scala提供了一个Breaks类（位于包scala.util.control）。Breaks类有两个方法用于对循环结构进行控制，即breakable和break</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">breakable&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(...) <span class="keyword">break</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> util.control.<span class="type">Breaks</span>._ <span class="comment">//导入Breaks类的所有方法</span></span><br><span class="line"><span class="keyword">val</span> array = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">breakable&#123;</span><br><span class="line"><span class="keyword">for</span>(i&lt;- array)&#123;</span><br><span class="line">       <span class="keyword">if</span>(i&gt;<span class="number">5</span>) <span class="keyword">break</span> <span class="comment">//跳出breakable，终止for循环，相当于Java中的break</span></span><br><span class="line">println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的for语句将输出1，3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i&lt;- array)&#123;</span><br><span class="line">    breakable&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">5</span>) <span class="keyword">break</span> </span><br><span class="line">        <span class="comment">//跳出breakable，终止当次循环，相当于Java的continue        println(i)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 上面的for语句将输出1，3，5，4</span></span><br></pre></td></tr></table></figure>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h3><p>数组：一种可变的、可索引的、元素具有相同类型的数据集合</p>
<p>Scala提供了参数化类型的通用数组类Array[T]，其中T可以是任意的Scala类型，可以通过显式指定类型或者通过隐式推断来实例化一个数组</p>
<p>声明一个字符串数组</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myStrArr = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>) <span class="comment">//声明一个长度为3的字符串数组，每个数组元素初始化为null</span></span><br><span class="line"></span><br><span class="line">myStrArr(<span class="number">0</span>) = <span class="string">&quot;BigData&quot;</span></span><br><span class="line">myStrArr(<span class="number">1</span>) = <span class="string">&quot;Hadoop&quot;</span></span><br><span class="line">myStrArr(<span class="number">2</span>) = <span class="string">&quot;Spark&quot;</span></span><br><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">0</span> to <span class="number">2</span>) println(myStrArr(i))</span><br></pre></td></tr></table></figure>

<p>可以不给出数组类型，Scala会自动根据提供的初始化数据来推断出数组的类型</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intValueArr = <span class="type">Array</span>(<span class="number">12</span>,<span class="number">45</span>,<span class="number">33</span>)</span><br><span class="line"><span class="keyword">val</span> myStrArr = <span class="type">Array</span>(<span class="string">&quot;BigData&quot;</span>,<span class="string">&quot;Hadoop&quot;</span>,<span class="string">&quot;Spark&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>多维数组的创建：调用Array的ofDim方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span>  myMatrix = <span class="type">Array</span>.ofDim[<span class="type">Int</span>](<span class="number">3</span>,<span class="number">4</span>)  <span class="comment">//类型实际就是Array[Array[Int]]</span></span><br><span class="line"><span class="keyword">val</span>  myCube = <span class="type">Array</span>.ofDim[<span class="type">String</span>](<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>)  <span class="comment">//类型实际是Array[Array[Array[Int]]]</span></span><br></pre></td></tr></table></figure>

<p>可以使用多级圆括号来访问多维数组的元素，例如myMatrix(0)(1)返回第一行第二列的元素</p>
<h3 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h3><p>元组是对多个不同类型对象的一种简单封装。定义元组最简单的方法就是把多个元素用逗号分开并用圆括号包围起来。</p>
<p>使用下划线“_”加上从1开始的索引值，来访问元组的元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> tuple = (<span class="string">&quot;BigData&quot;</span>,<span class="number">1</span>,<span class="number">23.0</span>)</span><br><span class="line">scala&gt; print(tuple._1)</span><br><span class="line"><span class="string">&quot;BigData&quot;</span></span><br><span class="line">scala&gt; print(tuple._2)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">scala&gt; print(tuple._3)</span><br><span class="line"><span class="number">23.0</span></span><br></pre></td></tr></table></figure>

<h3 id="容器（Collection）"><a href="#容器（Collection）" class="headerlink" title="容器（Collection）"></a>容器（Collection）</h3><p>Scala提供了一套丰富的容器（collection）库，包括序列（Sequence）、集合（Set）、映射（Map）等<br>Scala用了三个包来组织容器类，分别是scala.collection 、scala.collection.mutable和scala.collection.immutable<br>scala.collection封装了可变容器和不可变容器的超类或特质，定义了可变容器和不可变容器的一些通用操作</p>
<p><img data-src="scala-learning/01.png"></p>
<p>所有容器的根为Traverable特质，表示可遍历的，它为所有的容器类定义了抽象的foreach方法，该方法用于对容器元素进行遍历操作。混入Traverable特质的容器类必须给出foreach方法的具体实现。Traverable的下一级为Iterable特质，表示元素可一个个地依次迭代，该特质定义了一个抽象的iterator方法，混入该特质的容器必须实现iterator方法，返回一个迭代器（Iterator），另外，Iterable特质还给出了其从Traverable继承的foreach方法的一个默认实现，即通过迭代器进行遍历。</p>
<p>在Iterable下的继承层次包括三个特质，分别是序列（Seq）、映射（Map）和 集合（Set），这三种容器最大的区别是其元素的索引方式，序列是按照从0开始的整数进行索引的，映射是按照键值进行索引的，而集合是没有索引的。</p>
<h3 id="序列（Sequence）"><a href="#序列（Sequence）" class="headerlink" title="序列（Sequence）"></a>序列（Sequence）</h3><p>序列（Sequence）: 元素可以按照特定的顺序访问的容器。序列中每个元素均带有一个从0开始计数的固定索引位置</p>
<p>序列容器的根是collection.Seq特质。其具有两个子特质 LinearSeq和IndexedSeq。LinearSeq序列具有高效的 head 和 tail 操作，而IndexedSeq序列具有高效的随机存储操作</p>
<p>实现了特质LinearSeq的常用序列有列表（List）和队列（Queue）。实现了特质IndexedSeq的常用序列有可变数组（ArrayBuffer）和向量（Vector）</p>
<h4 id="列表-List"><a href="#列表-List" class="headerlink" title="列表(List)"></a>列表(List)</h4><p>列表: 一种共享相同类型的不可变的对象序列。定义在scala.collection.immutable包中</p>
<p>不同于Java的java.util.List，scala的List一旦被定义，其值就不能改变，因此声明List时必须初始化</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strList=<span class="type">List</span>(<span class="string">&quot;BigData&quot;</span>,<span class="string">&quot;Hadoop&quot;</span>,<span class="string">&quot;Spark&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>列表有头部和尾部的概念，可以分别使用head和tail方法来获取</p>
<p>head返回的是列表第一个元素的值</p>
<p>tail返回的是除第一个元素外的其它值构成的新列表，这体现出列表具有递归的链表结构</p>
<p>strList.head将返回字符串”BigData”，strList.tail返回List (“Hadoop”,”Spark”)</p>
<p>不能用new来建立List（原型：<strong>sealed abstract class List[+A]</strong> ）</p>
<p>补充相同类型：对于包括List在内的所有容器类型，如果没有显式指定元素类型，Scala会自动选择所有初始值的最近公共类型来作为元素的类型。因为Scala的所有对象都来自共同的根Any，因此，原则上容器内可以容纳任意不同类型的成员。例如：val x=List(1,3.4,”Spark”)</p>
<p>构造列表常用的方法是通过在已有列表前端增加元素，使用的操作符为<code>::</code>，例如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> otherList=<span class="string">&quot;Apache&quot;</span>::strList</span><br></pre></td></tr></table></figure>

<p>执行该语句后strList保持不变，而otherList将成为一个新的列表：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="string">&quot;Apache&quot;</span>,<span class="string">&quot;BigData&quot;</span>,<span class="string">&quot;Hadoop&quot;</span>,<span class="string">&quot;Spark&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Scala还定义了一个空列表对象Nil，借助Nil，可以将多个元素用操作符<code>::</code>串起来初始化一个列表</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intList = <span class="number">1</span>::<span class="number">2</span>::<span class="number">3</span>::<span class="type">Nil</span></span><br></pre></td></tr></table></figure>

<p>与</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intList = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>等效</p>
<p>注意：除了head、tail操作是常数时间O(1)，其它按索引访问的操作都需要从头开始遍历，因此是线性时间复杂度O(N)。</p>
<p><code>::</code>是向右结合的（<code>:</code>结尾的操作符都是向右结合）</p>
<h4 id="向量-Vector"><a href="#向量-Vector" class="headerlink" title="向量(Vector)"></a>向量(Vector)</h4><p>Vetor可以实现所有访问操作都是常数时间。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> vec1=<span class="type">Vector</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">vec1: scala.collection.immutable.<span class="type">Vector</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> vec2 = <span class="number">3</span> +: <span class="number">4</span> +: vec1</span><br><span class="line">vec2: scala.collection.immutable.<span class="type">Vector</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> vec3 = vec2 :+ <span class="number">5</span></span><br><span class="line">vec3: scala.collection.immutable.<span class="type">Vector</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">scala&gt; vec3(<span class="number">3</span>)</span><br><span class="line">res6: <span class="type">Int</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><code>+:</code>和<code>:+</code>是Seq的方法，执行后vector本身没变</p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><p>Range类：一种特殊的、带索引的不可变数字等差序列。其包含的值为从给定起点按一定步长增长(减小)到指定终点的所有数值</p>
<p>Range可以支持创建不同数据类型的数值序列，包括Int、Long、Float、Double、Char、BigInt和BigDecimal等</p>
<ul>
<li>创建一个从1到5的数值序列，包含区间终点5，步长为1</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> r=<span class="keyword">new</span> <span class="type">Range</span>(<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">scala&gt; <span class="number">1</span> to <span class="number">5</span></span><br><span class="line">scala&gt; <span class="number">1.</span>to(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个从1到5的数值序列，不包含区间终点5，步长为1</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="number">1</span> until <span class="number">5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个从1到10的数值序列，包含区间终点10，步长为2</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="number">1</span> to <span class="number">10</span> by <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个Float类型的数值序列，从0.5f到5.9f，步长为0.8f</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="number">0.5</span>f to <span class="number">5.9</span>f by <span class="number">0.8</span>f</span><br></pre></td></tr></table></figure>

<p><code>1to 10 by 2</code>等效于<code>1.to(10).by(2)</code>，调用了Range的by方法</p>
<h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><p>集合(set)：不重复元素的容器（collection）</p>
<p>列表（List）中的元素是按照插入的先后顺序来组织的，但是，“集合”中的元素并不会记录元素的插入顺序，而是以“哈希”方法对元素的值进行组织，所以，它允许你快速地找到某个元素</p>
<p>集合包括<strong>可变集</strong>和<strong>不可变集</strong>，分别位于<code>scala.collection.mutable</code>包和<code>scala.collection.immutable</code>包，缺省情况下创建的是不可变集</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySet = <span class="type">Set</span>(<span class="string">&quot;Hadoop&quot;</span>,<span class="string">&quot;Spark&quot;</span>)</span><br><span class="line">mySet += <span class="string">&quot;Scala&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果要声明一个可变集，则需要提前引入scala.collection.mutable.Set</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">Set</span></span><br><span class="line"><span class="keyword">val</span> myMutableSet = <span class="type">Set</span>(<span class="string">&quot;Database&quot;</span>,<span class="string">&quot;BigData&quot;</span>)</span><br><span class="line">myMutableSet += <span class="string">&quot;Cloud Computing&quot;</span> </span><br></pre></td></tr></table></figure>

<h3 id="映射（Map）"><a href="#映射（Map）" class="headerlink" title="映射（Map）"></a>映射（Map）</h3><p>映射(Map)：一系列键值对的容器。键是唯一的，但值不一定是唯一的。可以根据键来对值进行快速的检索</p>
<p>Scala 的映射包含了可变的和不可变的两种版本，分别定义在包scala.collection.mutable 和scala.collection.immutable 里。默认情况下，Scala中使用不可变的映射。如果想使用可变映射，必须明确地导入scala.collection.mutable.Map</p>
<p>其中，操作符”-&gt;”是定义二元组的简写方式，它会返回一个包含调用者和传入参数的二元组</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> university = <span class="type">Map</span>(<span class="string">&quot;XMU&quot;</span> -&gt; <span class="string">&quot;Xiamen University&quot;</span>, <span class="string">&quot;THU&quot;</span> -&gt; <span class="string">&quot;Tsinghua University&quot;</span>,<span class="string">&quot;PKU&quot;</span>-&gt;<span class="string">&quot;Peking University&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果要获取映射中的值，可以通过键来获取</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(university(<span class="string">&quot;XMU&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>对于这种访问方式，如果给定的键不存在，则会抛出异常，为此，访问前可以先调用contains方法确定键是否存在</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> xmu = <span class="keyword">if</span> (university.contains(<span class="string">&quot;XMU&quot;</span>)) university(<span class="string">&quot;XMU&quot;</span>) <span class="keyword">else</span> <span class="number">0</span> println(xmu)</span><br></pre></td></tr></table></figure>

<h4 id="可变的映射"><a href="#可变的映射" class="headerlink" title="可变的映射"></a>可变的映射</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.mutable.<span class="type">Map</span></span><br><span class="line"><span class="keyword">val</span> university2 = <span class="type">Map</span>(<span class="string">&quot;XMU&quot;</span> -&gt; <span class="string">&quot;Xiamen University&quot;</span>, <span class="string">&quot;THU&quot;</span> -&gt; <span class="string">&quot;Tsinghua University&quot;</span>,<span class="string">&quot;PKU&quot;</span>-&gt;<span class="string">&quot;Peking University&quot;</span>)</span><br><span class="line">university2(<span class="string">&quot;XMU&quot;</span>) = <span class="string">&quot;Ximan University&quot;</span> <span class="comment">//更新已有元素的值</span></span><br><span class="line">university2(<span class="string">&quot;FZU&quot;</span>) = <span class="string">&quot;Fuzhou University&quot;</span> <span class="comment">//添加新元素</span></span><br></pre></td></tr></table></figure>

<p>也可以使用+=操作来添加新的元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">university2 + = (<span class="string">&quot;TJU&quot;</span>-&gt;<span class="string">&quot;Tianjin University&quot;</span>) <span class="comment">//添加一个新元素</span></span><br><span class="line">university2 + = (<span class="string">&quot;SDU&quot;</span>-&gt;<span class="string">&quot;Shandong University&quot;</span>,<span class="string">&quot;WHU&quot;</span>-&gt;<span class="string">&quot;Wuhan University&quot;</span>) <span class="comment">//同时添加两个新元素</span></span><br></pre></td></tr></table></figure>

<h3 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h3><p>迭代器（Iterator）不是一个容器，而是提供了按顺序访问容器元素的数据结构</p>
<p>迭代器包含两个基本操作：next和hasNext。next可以返回迭代器的下一个元素，hasNext用于检测是否还有下一个元素</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> iter = <span class="type">Iterator</span>(<span class="string">&quot;Hadoop&quot;</span>,<span class="string">&quot;Spark&quot;</span>,<span class="string">&quot;Scala&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext) &#123;</span><br><span class="line">    println(iter.next())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议：除next和hasnext方法外，在对一个迭代器调用了某个方法后，不要再次使用该迭代器</p>
<p>1、尽管构造一个迭代器与构造一个容器很类似，但迭代器并不是一个容器类，因为不能随机访问迭代器的元素，而只能按从前往后的顺序依次访问其元素。</p>
<p>2、实际上，迭代器的大部分方法都会改变迭代器的状态，例如，调用length方法会返回迭代器元素的个数，但是，调用结束后，迭代器已经没有元素了，再次进行相关操作会报错。</p>
<h1 id="面向对象编程基础"><a href="#面向对象编程基础" class="headerlink" title="面向对象编程基础"></a>面向对象编程基础</h1><p>作为一个运行一个JVM上的语言，Scala毫无疑问首先是面向对象的语言。尽管在具体的数据处理部分，函数式编程在Scala中已成为首选方案，但在上层的架构组织上，仍然需要采用面向对象的模型，这对于大型的应用程序尤其必不可少。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">       <span class="comment">//这里定义类的字段和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段定义：用val或var关键字进行定义</p>
<p>方法定义：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">方法名</span></span>(参数列表):返回结果类型=&#123;方法体&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">increment</span></span>(step:<span class="type">Int</span>):<span class="type">Unit</span> = &#123; value += step&#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">current</span></span>():<span class="type">Int</span> = &#123;value&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用new关键字创建一个类的实例</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myCounter = <span class="keyword">new</span> <span class="type">Counter</span></span><br><span class="line">myCounter.value = <span class="number">5</span> <span class="comment">//访问字段</span></span><br><span class="line">myCounter. increment(<span class="number">3</span>) <span class="comment">//调用方法</span></span><br><span class="line">println(myCounter.current) <span class="comment">//调用无参数方法时，可以省略方法名后的括号</span></span><br></pre></td></tr></table></figure>

<h3 id="类成员的可见性"><a href="#类成员的可见性" class="headerlink" title="类成员的可见性"></a>类成员的可见性</h3><p>Scala类中所有成员的默认可见性为公有，任何作用域内都能直接访问公有成员</p>
<p>除了默认的公有可见性，Scala也提供<code>private</code>和<code>protected</code>，其中，private成员只对本类型和嵌套类型可见；<code>protected</code>成员对本类型和其继承类型都可见</p>
<p>为了避免直接暴露public字段，建议将字段设置为<code>private</code>，对于<code>private</code>字段，Scala采用类似Java中的<code>getter</code>和<code>setter</code>方法，定义了两个成对的方法<code>value</code>和<code>value_=</code>进行读取和修改</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateValue = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">value</span> </span>= privateValue</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">value_=</span></span>(newValue: <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      privateValue = newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">increment</span></span>(step: <span class="type">Int</span>) = &#123;</span><br><span class="line">    value += step</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">current</span> </span>= value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> myCounter = <span class="keyword">new</span> <span class="type">Counter</span></span><br><span class="line">myCounter: <span class="type">Counter</span> = <span class="type">Counter</span><span class="meta">@f</span>591271</span><br><span class="line">scala&gt; myCounter.value_=(<span class="number">3</span>) <span class="comment">//为privateValue设置新的值</span></span><br><span class="line">scala&gt; println(myCounter.value)<span class="comment">//访问privateValue的当前值</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>Scala语法中有如下规范，当编译器看到以<code>value</code>和<code>value_=</code>这种成对形式出现的方法时，它允许用户去掉下划线_，而采用类似赋值表达式的形式</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myCounter.value= <span class="number">3</span> <span class="comment">// 等效于myCounter.value_=(3)</span></span><br></pre></td></tr></table></figure>

<p>如果class Counter{}中，使用 private var value =0，那么，使用scalac命令编译该程序，会出现myCounter.value=3变量无法访问的错误，因为是私有变量，不能从外部访问。</p>
<h3 id="方法的定义方式"><a href="#方法的定义方式" class="headerlink" title="方法的定义方式"></a>方法的定义方式</h3><p>基本语法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">方法名</span></span>(参数列表):返回结果类型=&#123;方法体&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法参数前不能加上val或var，所有的方法参数都是不可变类型</li>
<li>无参数的方法定义时可以省略括号，这时调用时也不能带有括号；如果定义时带有括号，则调用时可以带括号，也可以不带括号</li>
<li>方法名后面的圆括号()可以用大括号{}来代替</li>
<li>如果方法只有一个参数，可以省略点号（.）而采用中缀操作符调用方法</li>
<li>如果方法体只有一条语句，可以省略方法体两边的大括号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Counter() &#123;</span><br><span class="line">  var value &#x3D; 0</span><br><span class="line"></span><br><span class="line">  def increment(step: Int):Unit &#x3D; &#123;</span><br><span class="line">    value +&#x3D; step</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def current:Int &#x3D; value</span><br><span class="line"></span><br><span class="line">  def getValue():Int &#x3D; value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> c=<span class="keyword">new</span> <span class="type">Counter</span></span><br><span class="line">c: <span class="type">Counter</span> = <span class="type">Counter</span>@<span class="number">30</span>ab4b0e</span><br><span class="line">scala&gt; c increment <span class="number">5</span> <span class="comment">//中缀调用法</span></span><br><span class="line">scala&gt; c.getValue()     <span class="comment">//getValue定义中有括号，可以带括号调用</span></span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">scala&gt; c.getValue <span class="comment">// getValue定义中有括号，也可不带括号调用</span></span><br><span class="line">res1: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">scala&gt; c.current() <span class="comment">// current定义中没有括号，不可带括号调用</span></span><br><span class="line">&lt;console&gt;:<span class="number">13</span>: error: <span class="type">Int</span> does not take parameters</span><br><span class="line">       c.current()</span><br><span class="line">                ^</span><br><span class="line">scala&gt; c.current  <span class="comment">// current定义中没有括号，只能不带括号调用</span></span><br><span class="line">res3: <span class="type">Int</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当方法的返回结果类型可以从最后的表达式推断出时，可以省略结果类型</li>
<li>如果方法返回类型为Unit，可以同时省略返回结果类型和等号，但不能省略大括号</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span></span>(step:<span class="type">Int</span>) &#123; value += step &#125;<span class="comment">//赋值表达式的值为Unit类型</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">current</span></span>()= value <span class="comment">//根据value的类型自动推断出返回类型为Int型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>Scala类的定义主体就是类的构造器，称为主构造器。在类名之后用圆括号列出主构造器的参数列表</p>
<p>主构造器的参数前可以使用val或var关键字，Scala内部将自动为这些参数创建私有字段，并提供对应的访问方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Counter</span>(<span class="params">var name:<span class="type">String</span></span>) <span class="title">//定义一个带字符串参数的简单类</span></span></span><br><span class="line"><span class="class"><span class="title">defined</span> <span class="title">class</span> <span class="title">Counter</span></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">var</span> <span class="title">mycounter</span> </span>= <span class="keyword">new</span> <span class="type">Counter</span>(<span class="string">&quot;Runner&quot;</span>)</span><br><span class="line">mycounter: <span class="type">Counter</span> = <span class="type">Counter</span>@<span class="number">17</span>fcc4f7</span><br><span class="line">scala&gt; println(mycounter.name) <span class="comment">//调用读方法</span></span><br><span class="line"><span class="type">Runner</span></span><br><span class="line">scala&gt; mycounter.name_=(<span class="string">&quot;Timer&quot;</span>) <span class="comment">//调用写方法</span></span><br><span class="line">scala&gt; mycounter.name = <span class="string">&quot;Timer&quot;</span><span class="comment">// 更直观地调用写方法，和上句等效</span></span><br><span class="line">mycounter.name: <span class="type">String</span> = <span class="type">Timer</span></span><br></pre></td></tr></table></figure>

<p> 如果不希望将构造器参数成为类的字段，只需要省略关键字var或者val</p>
<ul>
<li><p>Scala类可以包含零个或多个辅助构造器（auxiliary constructor）。辅助构造器使用this进行定义，this的返回类型为Unit</p>
</li>
<li><p>每个辅助构造器的第一个表达式必须是调用一个此前已经定义的辅助构造器或主构造器，调用的形式为“this(参数列表)”</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> value = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> step = <span class="number">1</span> <span class="comment">//计算器的默认递进步长</span></span><br><span class="line">    println(<span class="string">&quot;the main constructor&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>)&#123; <span class="comment">//第一个辅助构造器</span></span><br><span class="line">        <span class="keyword">this</span>() <span class="comment">//调用主构造器</span></span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        printf(<span class="string">&quot;the first auxiliary constructor,name:%s\n&quot;</span>,name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span> </span>(name: <span class="type">String</span>,step: <span class="type">Int</span>)&#123; <span class="comment">//第二个辅助构造器</span></span><br><span class="line">        <span class="keyword">this</span>(name) <span class="comment">//调用前一个辅助构造器</span></span><br><span class="line">        <span class="keyword">this</span>.step = step</span><br><span class="line">       printf(<span class="string">&quot;the second auxiliary constructor,name:%s,step:%d\n&quot;</span>,name,step)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span></span>(step: <span class="type">Int</span>): <span class="type">Unit</span> = &#123; value += step&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">current</span></span>(): <span class="type">Int</span> = &#123;value&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> c1=<span class="keyword">new</span> <span class="type">Counter</span></span><br><span class="line">the main constructor</span><br><span class="line">c1: <span class="type">Counter</span> = <span class="type">Counter</span>@<span class="number">319</span>c6b2</span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">val</span> c2=<span class="keyword">new</span> <span class="type">Counter</span>(<span class="string">&quot;the 2nd Counter&quot;</span>)</span><br><span class="line">the main constructor</span><br><span class="line">the first auxiliary constructor,name:the <span class="number">2</span>nd <span class="type">Counter</span></span><br><span class="line">c2: <span class="type">Counter</span> = <span class="type">Counter</span>@<span class="number">4</span>ed6c602</span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">val</span> c3=<span class="keyword">new</span> <span class="type">Counter</span>(<span class="string">&quot;the 3rd Counter&quot;</span>,<span class="number">2</span>)</span><br><span class="line">the main constructor</span><br><span class="line">the first auxiliary constructor,name:the <span class="number">3</span>rd <span class="type">Counter</span></span><br><span class="line">the second auxiliary constructor,name:the <span class="number">3</span>rd <span class="type">Counter</span>,step:<span class="number">2</span></span><br><span class="line">c3: <span class="type">Counter</span> = <span class="type">Counter</span>@<span class="number">64</span>fab83b</span><br></pre></td></tr></table></figure>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h3><p>Scala采用单例对象（singleton object）来实现与Java静态成员同样的功能</p>
<p>使用object 关键字定义单例对象</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastId = <span class="number">0</span>  <span class="comment">//一个人的身份编号</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newPersonId</span></span>() = &#123;</span><br><span class="line">        lastId +=<span class="number">1</span></span><br><span class="line">        lastId</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例对象的使用与一个普通的类实例一样：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; printf(<span class="string">&quot;The first person id: %d.\n&quot;</span>,<span class="type">Person</span>.newPersonId())</span><br><span class="line"><span class="type">The</span> first person id: <span class="number">1.</span></span><br><span class="line">scala&gt; printf(<span class="string">&quot;The second person id：%d.\n&quot;</span>,<span class="type">Person</span>.newPersonId())</span><br><span class="line"><span class="type">The</span> second person id：<span class="number">2.</span></span><br><span class="line">scala&gt; printf(<span class="string">&quot;The third person id: %d.\n&quot;</span>,<span class="type">Person</span>.newPersonId())</span><br><span class="line"><span class="type">The</span> third person id: <span class="number">3.</span></span><br></pre></td></tr></table></figure>

<h4 id="伴生对象和孤立对象"><a href="#伴生对象和孤立对象" class="headerlink" title="伴生对象和孤立对象"></a>伴生对象和孤立对象</h4><ul>
<li><p>当一个单例对象和它的同名类一起出现时，这时的单例对象被称为这个同名类的“伴生对象”（companion object）。相应的类被称为这个单例对象的“伴生类”</p>
</li>
<li><p>类和它的伴生对象必须存在于同一个文件中，可以相互访问私有成员</p>
</li>
<li><p>没有同名类的单例对象，被称为孤立对象（standalone object）。一般情况下，Scala程序的入口点main方法就是定义在一个孤立对象里</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name:<span class="type">String</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> id = <span class="type">Person</span>.newPersonId() <span class="comment">//调用了伴生对象中的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>() &#123;</span><br><span class="line">        printf(<span class="string">&quot;The id of %s is %d.\n&quot;</span>,name,id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastId = <span class="number">0</span>  <span class="comment">//一个人的身份编号</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newPersonId</span></span>() = &#123;</span><br><span class="line">        lastId +=<span class="number">1</span></span><br><span class="line">        lastId</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> person1 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;Lilei&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> person2 = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">&quot;Hanmei&quot;</span>)</span><br><span class="line">        person1.info()</span><br><span class="line">        person2.info()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">The</span> id of <span class="type">Lilei</span> is <span class="number">1.</span></span><br><span class="line"><span class="type">The</span> id of <span class="type">Hanmei</span> is <span class="number">2.</span></span><br></pre></td></tr></table></figure>

<h3 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h3><p>思考下行代码的执行过程：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myStrArr = <span class="type">Array</span>(<span class="string">&quot;BigData&quot;</span>,<span class="string">&quot;Hadoop&quot;</span>,<span class="string">&quot;Spark&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>Scala自动调用Array类的伴生对象Array中的一个称为apply的方法，来创建一个Array对象myStrArr</li>
<li>apply方法调用约定：用括号传递给类实例或单例对象名一个或多个参数时，Scala 会在相应的类或对象中查找方法名为apply且参数列表与传入的参数一致的方法，并用传入的参数来调用该apply方法</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApplyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(param: <span class="type">String</span>)&#123;</span><br><span class="line">         println(<span class="string">&quot;apply method called: &quot;</span> + param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> myObject = <span class="keyword">new</span> <span class="type">TestApplyClass</span></span><br><span class="line">myObject: <span class="type">TestApplyClass</span> = <span class="type">TestApplyClass</span>@<span class="number">11</span>b352e9</span><br><span class="line">scala&gt; myObject(<span class="string">&quot;Hello Apply&quot;</span>)<span class="comment">// 自动调用类中定义的apply方法，等同于下句</span></span><br><span class="line">apply method called: <span class="type">Hello</span> <span class="type">Apply</span></span><br><span class="line">scala&gt; myObject.apply(<span class="string">&quot;Hello Apply&quot;</span>)  <span class="comment">//手动调用apply方法</span></span><br><span class="line">apply method called: <span class="type">Hello</span> <span class="type">Apply</span></span><br></pre></td></tr></table></figure>

<p>伴生对象中的apply方法：将所有类的构造方法以apply方法的形式定义在伴生对象中，这样伴生对象就像生成类实例的工厂，而这些apply方法也被称为工厂方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>() &#123;</span><br><span class="line">        println(<span class="string">&quot;Car name is &quot;</span>+ name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>) = <span class="keyword">new</span> <span class="type">Car</span>(name) <span class="comment">//调用伴生类Car的构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTestApply</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span> </span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> mycar = <span class="type">Car</span>(<span class="string">&quot;BMW&quot;</span>) <span class="comment">//调用伴生对象中的apply方法</span></span><br><span class="line">    mycar.info() <span class="comment">//输出结果为“Car name is BMW”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么要设计apply方法？</p>
<ul>
<li><p>保持对象和函数之间使用的一致性</p>
</li>
<li><p>面向对象：“对象.方法” VS  数学：“函数(参数)”</p>
</li>
<li><p>Scala中一切都是对象，包括函数也是对象。Scala中的函数既保留括号调用样式，也可以使用点号调用形式，其对应的方法名即为apply</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">add=</span></span>(x:<span class="type">Int</span>,y:<span class="type">Int</span>)=&gt;x+y  <span class="comment">//add是一个函数</span></span><br><span class="line">add: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span></span><br><span class="line">scala&gt; add(<span class="number">4</span>,<span class="number">5</span>)   <span class="comment">//采用数学界的括号调用样式</span></span><br><span class="line">res2: <span class="type">Int</span> = <span class="number">9</span></span><br><span class="line">scala&gt; add.apply(<span class="number">4</span>,<span class="number">5</span>) <span class="comment">//add也是对象，采用点号形式调用apply方法</span></span><br><span class="line">res3: <span class="type">Int</span> = <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>Scala的对象也可以看成函数，前提是该对象提供了apply方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>() &#123;</span><br><span class="line">    println(<span class="string">&quot;Car name is &quot;</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>) = <span class="keyword">new</span> <span class="type">Car</span>(name) <span class="comment">//调用伴生类Car的构造方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyTestApply</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">val</span> mycar = <span class="type">Car</span>(<span class="string">&quot;BMW&quot;</span>) <span class="comment">//调用伴生对象中的apply方法</span></span><br><span class="line">    mycar.info() <span class="comment">//输出结果为“Car name is BMW”</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="update方法"><a href="#update方法" class="headerlink" title="update方法"></a>update方法</h3><p>与apply方法类似的update方法也遵循相应的调用约定：当对带有括号并包括一到若干参数的对象进行赋值时，编译器将调用对象的update方法，并将括号里的参数和等号右边的值一起作为update方法的输入参数来执行调用</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;<span class="keyword">val</span> myStrArr = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">String</span>](<span class="number">3</span>)  <span class="comment">//声明一个长度为3的字符串数组，每个数组元素初始化为null</span></span><br><span class="line">scala&gt;myStrArr(<span class="number">0</span>) = <span class="string">&quot;BigData&quot;</span> <span class="comment">//实际上，调用了伴生类Array中的update方法，执行myStrArr.update(0,&quot;BigData&quot;)</span></span><br><span class="line">scala&gt;myStrArr(<span class="number">1</span>) = <span class="string">&quot;Hadoop&quot;</span> <span class="comment">//实际上，调用了伴生类Array中的update方法，执行myStrArr.update(1,&quot;Hadoop&quot;)</span></span><br><span class="line">scala&gt;myStrArr(<span class="number">2</span>) = <span class="string">&quot;Spark&quot;</span> <span class="comment">//实际上，调用了伴生类Array中的update方法，执行myStrArr.update(2,&quot;Spark&quot;)</span></span><br></pre></td></tr></table></figure>


<h3 id="unapply方法"><a href="#unapply方法" class="headerlink" title="unapply方法"></a>unapply方法</h3><ul>
<li><p>unapply方法用于对对象进行解构操作，与apply方法类似，该方法也会被自动调用</p>
</li>
<li><p>可以认为unapply方法是apply方法的反向操作，apply方法接受构造参数变成对象，而unapply方法接受一个对象，从中提取值</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">val brand: <span class="type">String</span>, val price: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>() &#123;</span><br><span class="line">    println(<span class="string">&quot;Car brand is &quot;</span> + brand + <span class="string">&quot; and price is &quot;</span> + price)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(brand: <span class="type">String</span>, price: <span class="type">Int</span>) = &#123;</span><br><span class="line">    println(<span class="string">&quot;Debug:calling apply ... &quot;</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Car</span>(brand, price)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(c: <span class="type">Car</span>): <span class="type">Option</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = &#123;</span><br><span class="line">    println(<span class="string">&quot;Debug:calling unapply ... &quot;</span>)</span><br><span class="line">    <span class="type">Some</span>((c.brand, c.price))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestUnapply</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="type">Car</span>(carbrand, carprice) = <span class="type">Car</span>(<span class="string">&quot;BMW&quot;</span>, <span class="number">800000</span>)</span><br><span class="line">    println(<span class="string">&quot;brand: &quot;</span> + carbrand + <span class="string">&quot; and carprice: &quot;</span> + carprice)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个类包含没有实现的成员，则必须使用abstract关键词进行修饰，定义为抽象类</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">val name:<span class="type">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> carBrand:<span class="type">String</span> <span class="comment">//字段没有初始化值，就是一个抽象字段</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>() <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greeting</span></span>() &#123;</span><br><span class="line">        println(<span class="string">&quot;Welcome to my car!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于上面的定义，说明几点：<br>（1）定义一个抽象类，需要使用关键字abstract<br>（2）定义一个抽象类的抽象方法，不需要关键字abstract，只要把方法体空着，不写方法体就可以<br>（3）抽象类中定义的字段，只要没有给出初始化值，就表示是一个抽象字段，但是，抽象字段必须要声明类型，否则编译会报错</p>
<h3 id="扩展类"><a href="#扩展类" class="headerlink" title="扩展类"></a>扩展类</h3><p>Scala只支持单一继承，而不支持多重继承。在类定义中使用extends关键字表示继承关系。定义子类时，需要注意：</p>
<ul>
<li><p>重载父类的抽象成员（包括字段和方法）时，override关键字是可选的；而重载父类的非抽象成员时，override关键字是必选的</p>
</li>
<li><p>只能重载val类型的字段，而不能重载var类型的字段。因为var类型本身就是可变的，所以，可以直接修改它的值，无需重载</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类的定义</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">//抽象字段，没有初始化值</span></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">id</span></span>: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//具体方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span></span>() = &#123;</span><br><span class="line">    println(<span class="string">&quot;this is animal&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;cat&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">id</span></span>: <span class="type">Int</span> = &#123;</span><br><span class="line">    name.hashCode</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">show</span></span>() = &#123;</span><br><span class="line">    println(<span class="string">&quot;this is cat&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">abstractTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="type">Cat</span>()</span><br><span class="line">    cat1.show()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Scala的类层次结构"><a href="#Scala的类层次结构" class="headerlink" title="Scala的类层次结构"></a>Scala的类层次结构</h3><p><img data-src="scala-learning/02.png" alt="Scala的类层次结构"></p>
<p>在字节码层面上，Scala 直接使用JVM 原生类型来表示值类型，并将它们的实例保存在栈或寄存器上。值类型没有构造器，不能使用new 关键字创建，只能通过用字面量来创建或者来自表达式运算结果。</p>
<p>之所以被称为引用类型，是因为它们的实例是分配在堆内存上，这些实例对应的变量实际是指向了堆中的相应位置</p>
<ul>
<li><p>Null是所有引用类型的子类，其唯一的实例为null，表示一个“空”对象，可以赋值给任何引用类型的变量，但不能赋值给值类型的变量</p>
</li>
<li><p>Nothing是所有其它类型的子类，包括Null。Nothing没有实例，主要用于异常处理函数的返回类型</p>
</li>
</ul>
<h3 id="Option类"><a href="#Option类" class="headerlink" title="Option类"></a>Option类</h3><ul>
<li><p>Scala提供null是为了实现在JVM与其它Java库的兼容性，但是，除非明确需要与Java库进行交互，否则，Scala建议尽量避免使用这种可能带来bug的null，而改用Option类</p>
</li>
<li><p>Option是一个抽象类，有一个具体的子类Some和一个对象None，其中，前者表示有值的情形，后者表示没有值</p>
</li>
<li><p>当方法不确定是否有对象返回时，可以让返回值类型为Option[T]，其中，T为类型参数。对于这类方法，如果确实有T类型的对象需要返回，会将该对象包装成一个Some对象并返回；如果没有值需要返回，将返回None</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">val name:<span class="type">String</span>,val price:<span class="type">Double</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">defined</span> <span class="title">class</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class"><span class="title">scala&gt;</span> <span class="title">val</span> <span class="title">books=Map</span>(<span class="params">&quot;hadoop&quot;-&gt;<span class="type">Book</span>(&quot;<span class="type">Hadoop</span>&quot;,35.5</span>),</span></span><br><span class="line"><span class="class">     <span class="title">|</span> &quot;<span class="title">spark</span>&quot;<span class="title">-&gt;Book</span>(<span class="params">&quot;<span class="type">Spark</span>&quot;,55.5</span>),</span></span><br><span class="line"><span class="class">     <span class="title">|</span> &quot;<span class="title">hbase</span>&quot;<span class="title">-&gt;Book</span>(<span class="params">&quot;<span class="type">Hbase</span>&quot;,26.0</span>)) <span class="title">//定义一个书名到书对象的映射</span></span></span><br><span class="line"><span class="class"><span class="title">books</span></span>: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Book</span>] =… </span><br><span class="line">scala&gt; books.get(<span class="string">&quot;hadoop&quot;</span>) <span class="comment">//返回该键所对应值的Some对象</span></span><br><span class="line">res0: <span class="type">Option</span>[<span class="type">Book</span>] = <span class="type">Some</span>(<span class="type">Book</span>(<span class="type">Hadoop</span>,<span class="number">35.5</span>))</span><br><span class="line">scala&gt; books.get(<span class="string">&quot;hive&quot;</span>) <span class="comment">// 不存在该键，返回None对象</span></span><br><span class="line">res1: <span class="type">Option</span>[<span class="type">Book</span>] = <span class="type">None</span></span><br><span class="line">scala&gt; books.get(<span class="string">&quot;hadoop&quot;</span>).get <span class="comment">//Some对象的get方法返回其包装的对象</span></span><br><span class="line">res2: <span class="type">Book</span> = <span class="type">Book</span>(<span class="type">Hadoop</span>,<span class="number">35.5</span>)</span><br><span class="line">scala&gt; books.get(<span class="string">&quot;hive&quot;</span>).get <span class="comment">// None对象的get方法会抛出异常</span></span><br><span class="line">java.util.<span class="type">NoSuchElementException</span>: <span class="type">None</span>.get</span><br><span class="line">  …</span><br><span class="line">scala&gt; books.get(<span class="string">&quot;hive&quot;</span>).getOrElse(<span class="type">Book</span>(<span class="string">&quot;Unknown name&quot;</span>,<span class="number">0</span>))</span><br><span class="line">res4: <span class="type">Book</span> = <span class="type">Book</span>(<span class="type">Unknown</span> name,<span class="number">0.0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h2><h3 id="特质概述"><a href="#特质概述" class="headerlink" title="特质概述"></a>特质概述</h3><ul>
<li><p>Java中提供了接口，允许一个类实现任意数量的接口</p>
</li>
<li><p>Scala中没有接口的概念，而是提供了“特质(trait)”，它不仅实现了接口的功能，还具备了很多其他的特性</p>
</li>
<li><p>Scala的特质是代码重用的基本单元，可以同时拥有抽象方法和具体方法</p>
</li>
<li><p>Scala中，一个类只能继承自一个超类，却可以实现多个特质，从而重用特质中的方法和字段，实现了多重继承</p>
</li>
</ul>
<h3 id="特质的定义"><a href="#特质的定义" class="headerlink" title="特质的定义"></a>特质的定义</h3><p>使用关键字trait定义特质</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxFlyHeight:<span class="type">Int</span>  <span class="comment">//抽象字段</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span></span>() <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">breathe</span></span>()&#123; <span class="comment">//具体的方法</span></span><br><span class="line">        println(<span class="string">&quot;I can breathe&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>特质既可以包含抽象成员，也可以包含非抽象成员。包含抽象成员时，不需要abstract关键字</li>
<li>特质可以使用extends继承其它的特质</li>
</ul>
<h3 id="把特质混入类中"><a href="#把特质混入类中" class="headerlink" title="把特质混入类中"></a>把特质混入类中</h3><p>可以使用extends或with关键字把特质混入类中</p>
<p>如果特质中包含抽象成员，则该类必须为这些抽象成员提供具体实现，除非该类被定义为抽象类</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>(<span class="params">flyHeight:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxFlyHeight:<span class="type">Int</span> = flyHeight  <span class="comment">//重载特质的抽象字段</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span></span>()&#123;</span><br><span class="line">        printf(<span class="string">&quot;I can fly at the height of %d.&quot;</span>,maxFlyHeight)</span><br><span class="line">    &#125; <span class="comment">//重载特质的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把上面定义的特质Flyable和类Bird封装到一个代码文件Bird.scala中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxFlyHeight:<span class="type">Int</span>  <span class="comment">//抽象字段</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span></span>() <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">breathe</span></span>()&#123; <span class="comment">//具体的方法</span></span><br><span class="line">        println(<span class="string">&quot;I can breathe&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>(<span class="params">flyHeight:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxFlyHeight:<span class="type">Int</span> = flyHeight  <span class="comment">//重载特质的抽象字段</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span></span>()&#123;</span><br><span class="line">        printf(<span class="string">&quot;I can fly at the height of %d&quot;</span>,maxFlyHeight)</span><br><span class="line">    &#125; <span class="comment">//重载特质的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> b=<span class="keyword">new</span> <span class="type">Bird</span>(<span class="number">100</span>)</span><br><span class="line">b: <span class="type">Bird</span> = <span class="type">Bird</span>@<span class="number">43</span>a51d00</span><br><span class="line"> </span><br><span class="line">scala&gt; b.fly()</span><br><span class="line"><span class="type">I</span> can fly at the height of <span class="number">100</span></span><br><span class="line">scala&gt; b.breathe()</span><br><span class="line"><span class="type">I</span> can breathe</span><br></pre></td></tr></table></figure>

<p>如果要混入多个特质，可以连续使用多个with</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxFlyHeight:<span class="type">Int</span>  <span class="comment">//抽象字段</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span></span>() <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">breathe</span></span>()&#123; <span class="comment">//具体的方法</span></span><br><span class="line">        println(<span class="string">&quot;I can breathe&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HasLegs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> legs:<span class="type">Int</span>   <span class="comment">//抽象字段</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span></span>()&#123;printf(<span class="string">&quot;I can walk with %d legs&quot;</span>,legs)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>(<span class="params">val category:<span class="type">String</span></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span></span>()&#123;println(<span class="string">&quot;This is a &quot;</span>+category)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>(<span class="params">flyHeight:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span>(<span class="params">&quot;<span class="type">Bird</span>&quot;</span>) <span class="keyword">with</span> <span class="title">Flyable</span> <span class="keyword">with</span> <span class="title">HasLegs</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxFlyHeight:<span class="type">Int</span> = flyHeight <span class="comment">//重载特质的抽象字段</span></span><br><span class="line">    <span class="keyword">val</span> legs=<span class="number">2</span> <span class="comment">//重载特质的抽象字段</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span></span>()&#123;</span><br><span class="line">       printf(<span class="string">&quot;I can fly at the height of %d&quot;</span>,maxFlyHeight)</span><br><span class="line">    &#125;<span class="comment">//重载特质的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> b=<span class="keyword">new</span> <span class="type">Bird</span>(<span class="number">108</span>)</span><br><span class="line">b: <span class="type">Bird</span> = <span class="type">Bird</span>@<span class="number">126675</span>fd</span><br><span class="line">scala&gt; b.info</span><br><span class="line"><span class="type">This</span> is a <span class="type">Bird</span></span><br><span class="line">scala&gt; b.fly</span><br><span class="line"><span class="type">I</span> can fly at the height of <span class="number">108</span></span><br><span class="line">scala&gt; b.move</span><br><span class="line"><span class="type">I</span> can walk <span class="keyword">with</span> <span class="number">2</span> legs</span><br></pre></td></tr></table></figure>

<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><h3 id="match语句"><a href="#match语句" class="headerlink" title="match语句"></a>match语句</h3><p>最常见的模式匹配是match语句，match语句用在当需要从多个分支中进行选择的场景</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.<span class="type">StdIn</span>._</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;Please input the score:&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> grade = readChar()</span><br><span class="line"></span><br><span class="line">grade <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &#x27;<span class="type">A</span>&#x27; =&gt; println(<span class="string">&quot;85-100&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> &#x27;<span class="type">B</span>&#x27; =&gt; println(<span class="string">&quot;70-84&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> &#x27;<span class="type">C</span>&#x27; =&gt; println(<span class="string">&quot;60-69&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> &#x27;<span class="type">D</span>&#x27; =&gt; println(<span class="string">&quot;&lt;60&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;error input!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通配符_相当于Java中的default分支</li>
</ul>
<ul>
<li>match结构中不需要break语句来跳出判断，Scala从前往后匹配到一个分支后，会自动跳出判断</li>
</ul>
<p>case后面的表达式可以是任何类型的常量，而不要求是整数类型</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.<span class="type">StdIn</span>._</span><br><span class="line">println(<span class="string">&quot;Please input a country:&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> country = readLine()</span><br><span class="line">country <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;China&quot;</span> =&gt; println(<span class="string">&quot;中国&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;America&quot;</span> =&gt; println(<span class="string">&quot;美国&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;Japan&quot;</span> =&gt; println(<span class="string">&quot;日本&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;我不认识!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了匹配特定的常量，还能匹配某种类型的所有值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (elem &lt;- <span class="type">List</span>(<span class="number">6</span>, <span class="number">9</span>, <span class="number">0.618</span>, <span class="string">&quot;Spark&quot;</span>, <span class="string">&quot;Hadoop&quot;</span>, <span class="symbol">&#x27;Hello</span>)) &#123;</span><br><span class="line">  <span class="keyword">val</span> str = elem <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; i + <span class="string">&quot; is an int value.&quot;</span> <span class="comment">//匹配整型的值，并赋值给i</span></span><br><span class="line">    <span class="keyword">case</span> d: <span class="type">Double</span> =&gt; d + <span class="string">&quot; is a double value.&quot;</span> <span class="comment">//匹配浮点型的值</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;Spark&quot;</span> =&gt; <span class="string">&quot;Spark is found.&quot;</span> <span class="comment">//匹配特定的字符串</span></span><br><span class="line">    <span class="keyword">case</span> s: <span class="type">String</span> =&gt; s + <span class="string">&quot; is a string value.&quot;</span> <span class="comment">//匹配其它字符串</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">&quot;unexpected value：&quot;</span> + elem <span class="comment">//与以上都不匹配</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6 is an int value.</span><br><span class="line">9 is an int value.</span><br><span class="line">0.618 is a double value.</span><br><span class="line">Spark is found.</span><br><span class="line">Hadoop is a string value.</span><br><span class="line">unexpected value：&#39;Hello</span><br></pre></td></tr></table></figure>

<p>可以在match表达式的case中使用守卫式（guard）添加一些过滤逻辑</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (elem &lt;- <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))&#123;</span><br><span class="line">  elem <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> _ <span class="keyword">if</span> (elem%<span class="number">2</span>==<span class="number">0</span>) =&gt; println(elem + <span class="string">&quot; is even.&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(elem + <span class="string">&quot; is odd.&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="case类"><a href="#case类" class="headerlink" title="case类"></a>case类</h3><ul>
<li><p>case类是一种特殊的类，它们经过优化以被用于模式匹配</p>
</li>
<li><p>当定义一个类时，如果在class关键字前加上case关键字，则该类称为case类</p>
</li>
<li><p>Scala为case类自动重载了许多实用的方法，包括toString、equals和hashcode方法</p>
</li>
<li><p>Scala为每一个case类自动生成一个伴生对象，其包括模板代码</p>
<ul>
<li>1个apply方法，因此，实例化case类的时候无需使用new关键字</li>
<li>1个unapply方法，该方法包含一个类型为伴生类的参数，返回的结果是Option类型，对应的类型参数是N元组，N是伴生类中主构造器参数的个数。Unapply方法用于对对象进行解构操作，在case类模式匹配中，该方法被自动调用，并将待匹配的对象作为参数传递给它</li>
</ul>
</li>
</ul>
<p>例如，假设有如下定义的一个case类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">brand: <span class="type">String</span>, price: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>则编译器自动生成的伴生对象是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span>  <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(brand:<span class="type">String</span>,price:<span class="type">Int</span>)= <span class="keyword">new</span> <span class="type">Car</span>(brand,price)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(c:<span class="type">Car</span>):<span class="type">Option</span>[(<span class="type">String</span>,<span class="type">Int</span>)]=<span class="type">Some</span>((c.brand,c.price))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">brand: <span class="type">String</span>, price: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">myBYDCar</span> </span>= <span class="type">Car</span>(<span class="string">&quot;BYD&quot;</span>, <span class="number">89000</span>)</span><br><span class="line"><span class="keyword">val</span> myBMWCar = <span class="type">Car</span>(<span class="string">&quot;BMW&quot;</span>, <span class="number">1200000</span>)</span><br><span class="line"><span class="keyword">val</span> myBenzCar = <span class="type">Car</span>(<span class="string">&quot;Benz&quot;</span>, <span class="number">1500000</span>)</span><br><span class="line"><span class="keyword">for</span> (car &lt;- <span class="type">List</span>(myBYDCar, myBMWCar, myBenzCar)) &#123;</span><br><span class="line">  car <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Car</span>(<span class="string">&quot;BYD&quot;</span>, <span class="number">89000</span>) =&gt; println(<span class="string">&quot;Hello, BYD!&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Car</span>(<span class="string">&quot;BMW&quot;</span>, <span class="number">1200000</span>) =&gt; println(<span class="string">&quot;Hello, BMW!&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Car</span>(brand, price) =&gt; println(<span class="string">&quot;Brand:&quot;</span> + brand + <span class="string">&quot;, Price: &quot;</span> + price + <span class="string">&quot;, do you want it ? &quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="包的定义"><a href="#包的定义" class="headerlink" title="包的定义"></a>包的定义</h3><ul>
<li>为了解决程序中命名冲突问题，Scala也和Java一样采用包(package)来层次化、模块化地组织程序</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span>  autodepartment</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>为了在任意位置访问MyClass类，需要使用autodepartment.MyClass</p>
</li>
<li><p>通过在关键字package后面加大括号，可以将程序的不同部分放在不同的包里。这样可以实现包的嵌套，相应的作用域也是嵌套的</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xmu &#123;</span><br><span class="line">    <span class="keyword">package</span> autodepartment &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">ControlCourse</span></span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">package</span> csdepartment &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span>  <span class="title">OSCourse</span></span>&#123;</span><br><span class="line">            <span class="keyword">val</span> cc = <span class="keyword">new</span> autodepartment.<span class="type">ControlCourse</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引用包成员"><a href="#引用包成员" class="headerlink" title="引用包成员"></a>引用包成员</h3><ul>
<li>可以用import 子句来引用包成员，这样可以简化包成员的访问方式</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xmu.autodepartment.<span class="type">ControlCourse</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> myos=<span class="keyword">new</span> <span class="type">ControlCourse</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用通配符下划线（_）引入类或对象的所有成员</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.<span class="type">StdIn</span>._</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i=readInt()</span><br><span class="line"><span class="keyword">var</span> f=readFloat()</span><br><span class="line"><span class="keyword">var</span> str=readLine()</span><br></pre></td></tr></table></figure>

<ul>
<li>Scala 隐式地添加了一些引用到每个程序前面，相当于每个Scala程序都隐式地以如下代码开始：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang._</span><br><span class="line"><span class="keyword">import</span> scala._</span><br><span class="line"><span class="keyword">import</span> <span class="type">Predef</span>._</span><br></pre></td></tr></table></figure>

<h1 id="函数式编程基础"><a href="#函数式编程基础" class="headerlink" title="函数式编程基础"></a>函数式编程基础</h1><h2 id="函数定义与使用"><a href="#函数定义与使用" class="headerlink" title="函数定义与使用"></a>函数定义与使用</h2><p>定义函数最通用的方法是作为某个类或者对象的成员，这种函数被称为方法，其定义的基本语法为</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">方法名</span></span>(参数列表):结果类型=&#123;方法体&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="scala-learning/image-20191216095217933.png" alt="image-20191216095217933"></p>
<p>字面量包括整数字面量、浮点数字面量、布尔型字面量、字符字面量、字符串字面量、符号字面量、函数字面量和元组字面量</p>
<p><img data-src="scala-learning/image-20191216095332315.png" alt="image-20191216095332315"></p>
<p>除了函数字面量我们会比较陌生以外，其他几种字面量都很容易理解</p>
<ul>
<li>函数字面量可以体现函数式编程的核心理念</li>
<li>在函数式编程中，函数是“头等公民”，可以像任何其他数据类型一样被传递和操作，也就是说，函数的使用方式和其他数据类型的使用方式完全一致了</li>
<li>这时，我们就可以像定义变量那样去定义一个函数，由此导致的结果是，函数也会和其他变量一样，开始有“值”</li>
<li>就像变量的“类型”和“值”是分开的两个概念一样，函数式编程中，函数的“类型”和“值”也成为两个分开的概念，函数的“值”，就是“函数字面量”</li>
</ul>
<p>下面一点点引导大家更好地理解函数的“类型”和“值”的概念</p>
<p>现在定义一个大家比较熟悉的传统类型的函数，定义的语法和我们之前介绍过的定义“类中的方法”类似（实际上，定义函数最常用的方法是作为某个对象的成员，这种函数被称为方法）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span></span>(value: <span class="type">Int</span>): <span class="type">Int</span> = &#123; value += <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义个这个函数的“类型”如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">Int</span>) =&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure>

<p>实际上，只有多个参数时（不同参数之间用逗号隔开），圆括号才是必须的，当参数只有一个时，圆括号可以省略，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Int</span> =&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure>

<p>上面就得到了函数的“类型”</p>
<p>下面看看如何得到函数的“值”</p>
<p>实际上，我们只要把函数定义中的类型声明部分去除，剩下的就是函数的“值”，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(value) =&gt; &#123;value += <span class="number">1</span>&#125; <span class="comment">//只有一条语句时，大括号可以省略</span></span><br></pre></td></tr></table></figure>

<p>注意：上面就是函数的“值”，需要注意的是，采用“=&gt;”而不是“=”，这是Scala的语法要求</p>
<p>现在，我们再按照大家比较熟悉的定义变量的方式，采用Scala语法来定义一个函数。</p>
<p>声明一个变量时，我们采用的形式是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> num: <span class="type">Int</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>照葫芦画瓢，我们也可以按照上面类似的形式来定义Scala中的函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> counter: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &#123; (value) =&gt; value += <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，在Scala中，函数已经是“头等公民”，单独剥离出来了“值”的概念，一个函数“值”就是函数字面量。这样，我们只要在某个需要声明函数的地方声明一个函数类型，在调用的时候传一个对应的函数字面量即可，和使用普通变量一模一样</p>
<p>我们不需要给每个函数命名，这时就可以使用匿名函数，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(num: <span class="type">Int</span>) =&gt; num * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>上面这种匿名函数的定义形式，我们经常称为“Lambda表达式”。“Lambda表达式”的形式如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(参数) =&gt; 表达式</span><br><span class="line"><span class="comment">//如果参数只有一个，参数的圆括号可以省略</span></span><br></pre></td></tr></table></figure>

<p>我们可以直接把匿名函数存放到变量中，下面是在Scala解释器中的执行过程：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> myNumFunc: <span class="type">Int</span>=&gt;<span class="type">Int</span> = (num: <span class="type">Int</span>) =&gt; num * <span class="number">2</span> </span><br><span class="line">myNumFunc: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &lt;function1&gt; <span class="comment">//这行是执行返回的结果</span></span><br><span class="line">scala&gt; println(myNumFunc(<span class="number">3</span>)) </span><br><span class="line"><span class="comment">//myNumFunc函数调用的时候，需要给出参数的值，这里传入3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>实际上，Scala具有类型推断机制，可以自动推断变量类型，比如下面两条语句都是可以的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> number: <span class="type">Int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> number =<span class="number">5</span> <span class="comment">//省略Int类型声明</span></span><br></pre></td></tr></table></figure>

<p>所以，上面的定义中，我们可以myNumFunc的类型声明，也就是去掉“Int=&gt;Int”，在Scala解释器中的执行过程如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> myNumFunc = (num: <span class="type">Int</span>) =&gt; num * <span class="number">2</span></span><br><span class="line">myNumFunc: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &lt;function1&gt;</span><br><span class="line">scala&gt; println(myNumFunc(<span class="number">3</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>下面我们再尝试一下，是否可以继续省略num的类型声明，在Scala解释器中的执行过程如下：</p>
<p><img data-src="scala-learning/image-20191216100052821.png" alt="image-20191216100052821"></p>
<p>可以看出，解释器会报错，因为，全部省略以后，实际上，解释器也无法推断出类型</p>
<p>下面我们尝试一下，省略num的类型声明，但是，给出myNumFunc的类型声明，在Scala解释器中的执行过程如下：</p>
<p><img data-src="scala-learning/image-20191216100115309.png" alt="image-20191216100115309"></p>
<p>不会报错，因为，给出了myNumFunc的类型为“Int=&gt;Int”以后，解释器可以推断出num类型为Int类型。</p>
<ul>
<li>当函数的每个参数在函数字面量内仅出现一次，可以省略“=&gt;”并用下划线“_”作为参数的占位符来简化函数字面量的表示，第一个下划线代表第一个参数，第二个下划线代表第二个参数，依此类推</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> counter = (_:<span class="type">Int</span>) + <span class="number">1</span> <span class="comment">//有类型时括号不能省略，等效于“x:Int=&gt;x+1”</span></span><br><span class="line">counter: <span class="type">Int</span> =&gt; <span class="type">Int</span> = &lt;function1&gt;</span><br><span class="line">scala&gt; <span class="keyword">val</span> add = (_:<span class="type">Int</span>) + (_:<span class="type">Int</span>) <span class="comment">//等效于“(a:Int,b:Int)=&gt;a+b”</span></span><br><span class="line">add: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span> = &lt;function2&gt;</span><br><span class="line">scala&gt; <span class="keyword">val</span> m1=<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">m1: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">scala&gt;<span class="keyword">val</span> m2=m1.map(_*<span class="number">2</span>)<span class="comment">//map接受一个函数作为参数，相当于“m1.map(x=&gt;x*2)”，参数的类型可以根据m1的元素类型推断出，所以可以省略。</span></span><br><span class="line">m2: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>当一个函数包含其它函数作为其参数或者返回结果为一个函数时，该函数被称为高阶函数</p>
<p>例：假设需要分别计算从一个整数到另一个整数的“连加和”、“平方和”以及“2的幂次和”</p>
<p><strong>方案一：不采用高阶函数</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">powerOfTwo</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = &#123;<span class="keyword">if</span>(x == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">2</span> * powerOfTwo(x<span class="number">-1</span>)&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumInts</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) <span class="number">0</span> <span class="keyword">else</span> a + sumInts(a + <span class="number">1</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumSquares</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) <span class="number">0</span> <span class="keyword">else</span> a*a + sumSquares(a + <span class="number">1</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumPowersOfTwo</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) <span class="number">0</span> <span class="keyword">else</span> powerOfTwo(a) + sumPowersOfTwo(a+<span class="number">1</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：假设需要分别计算从一个整数到另一个整数的“连加和”、“平方和”以及“2的幂次和”</p>
<p><strong>方案二：采用高阶函数</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">Int</span>, a: <span class="type">Int</span>, b: <span class="type">Int</span>):<span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b) <span class="number">0</span> <span class="keyword">else</span> f(a) + sum(f, a+<span class="number">1</span>, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; sum(x=&gt;x,<span class="number">1</span>,<span class="number">5</span>) <span class="comment">//直接传入一个匿名函数</span></span><br><span class="line"><span class="comment">//且省略了参数x的类型，因为可以由sum的参数类型推断出来</span></span><br><span class="line">res8: <span class="type">Int</span> = <span class="number">15</span></span><br><span class="line">scala&gt; sum(x=&gt;x*x,<span class="number">1</span>,<span class="number">5</span>) <span class="comment">//直接传入另一个匿名函数</span></span><br><span class="line">res9: <span class="type">Int</span> = <span class="number">55</span></span><br><span class="line">scala&gt; sum(powerOfTwo,<span class="number">1</span>,<span class="number">5</span>) <span class="comment">//传入一个已经定义好的方法</span></span><br><span class="line">res10: <span class="type">Int</span> = <span class="number">62</span></span><br></pre></td></tr></table></figure>

<h2 id="针对容器的操作"><a href="#针对容器的操作" class="headerlink" title="针对容器的操作"></a>针对容器的操作</h2><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><ul>
<li>Scala容器的标准遍历方法foreach</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>[<span class="type">U</span>](f: <span class="type">Elem</span> =&gt; <span class="type">U</span>) :<span class="type">Unit</span></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">scala&gt; <span class="keyword">val</span> f=(i:<span class="type">Int</span>)=&gt;println(i)</span><br><span class="line">f: <span class="type">Int</span> =&gt; <span class="type">Unit</span> = &lt;function1&gt;</span><br><span class="line">scala&gt; list.foreach(f)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>简化写法：“list foreach(i=&gt;println(i))”或“list foreach println”</p>
<p>所有容器的根为Traverable特质，表示可遍历的，它为所有的容器类定义了抽象的foreach方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> university = <span class="type">Map</span>(<span class="string">&quot;XMU&quot;</span> -&gt;<span class="string">&quot;Xiamen University&quot;</span>, <span class="string">&quot;THU&quot;</span> -&gt;<span class="string">&quot;Tsinghua University&quot;</span>,<span class="string">&quot;PKU&quot;</span>-&gt;<span class="string">&quot;Peking University&quot;</span>)</span><br><span class="line">university: scala.collection.mutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = ...</span><br><span class="line">scala&gt; university foreach&#123;kv =&gt; println(kv._1+<span class="string">&quot;:&quot;</span>+kv._2)&#125;</span><br><span class="line"><span class="type">XMU</span>:<span class="type">Xiamen</span> <span class="type">University</span></span><br><span class="line"><span class="type">THU</span>:<span class="type">Tsinghua</span> <span class="type">University</span></span><br><span class="line"><span class="type">PKU</span>:<span class="type">Peking</span> <span class="type">University</span></span><br></pre></td></tr></table></figure>

<p>简化写法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">university foreach&#123;x=&gt;x <span class="keyword">match</span> &#123;<span class="keyword">case</span> (k,v) =&gt; println(k+<span class="string">&quot;:&quot;</span>+v)&#125;&#125;</span><br><span class="line">university foreach&#123;<span class="keyword">case</span> (k,v) =&gt; println(k+<span class="string">&quot;:&quot;</span>+v)&#125;</span><br></pre></td></tr></table></figure>

<h3 id="映射操作"><a href="#映射操作" class="headerlink" title="映射操作"></a>映射操作</h3><ul>
<li>映射是指通过对容器中的元素进行某些运算来生成一个新的容器。两个典型的映射操作是map方法和flatMap方法</li>
<li>map方法（一对一映射）：将某个函数应用到集合中的每个元素，映射得到一个新的元素，map方法会返回一个与原容器类型大小都相同的新容器，只不过元素的类型可能不同</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> books =<span class="type">List</span>(<span class="string">&quot;Hadoop&quot;</span>,<span class="string">&quot;Hive&quot;</span>,<span class="string">&quot;HDFS&quot;</span>)</span><br><span class="line">books: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="type">Hadoop</span>, <span class="type">Hive</span>, <span class="type">HDFS</span>)</span><br><span class="line">scala&gt; books.map(s =&gt; s.toUpperCase)</span><br><span class="line"><span class="comment">//toUpperCase方法将一个字符串中的每个字母都变成大写字母</span></span><br><span class="line">res56: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="type">HADOOP</span>, <span class="type">HIVE</span>, <span class="type">HDFS</span>)</span><br><span class="line">scala&gt; books.map(s =&gt; s.length) <span class="comment">//将字符串映射到它的长度</span></span><br><span class="line">res57: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">6</span>, <span class="number">4</span>, <span class="number">4</span>) <span class="comment">//新列表的元素类型为Int</span></span><br></pre></td></tr></table></figure>

<ul>
<li>flatMap方法（一对多映射）：将某个函数应用到容器中的元素时，对每个元素都会返回一个容器（而不是一个元素），然后，flatMap把生成的多个容器“拍扁”成为一个容器并返回。返回的容器与原容器类型相同，但大小可能不同，其中元素的类型也可能不同</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; books flatMap (s =&gt; s.toList)</span><br><span class="line">res58: <span class="type">List</span>[<span class="type">Char</span>] = <span class="type">List</span>(<span class="type">H</span>, a, d, o, o, p, <span class="type">H</span>, i, v, e, <span class="type">H</span>, <span class="type">D</span>, <span class="type">F</span>, <span class="type">S</span>)</span><br></pre></td></tr></table></figure>

<h3 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h3><ul>
<li>过滤：遍历一个容器，从中获取满足指定条件的元素，返回一个新的容器</li>
<li>filter方法：接受一个返回布尔值的函数f作为参数，并将f作用到每个元素上，将f返回真值的元素组成一个新容器返回</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> university = <span class="type">Map</span>(<span class="string">&quot;XMU&quot;</span> -&gt;<span class="string">&quot;Xiamen University&quot;</span>, <span class="string">&quot;THU&quot;</span> -&gt;<span class="string">&quot;Tsinghua University&quot;</span>,<span class="string">&quot;PKU&quot;</span>-&gt;<span class="string">&quot;Peking University&quot;</span>,<span class="string">&quot;XMUT&quot;</span>-&gt;<span class="string">&quot;Xiamen University of Technology&quot;</span>)</span><br><span class="line">university: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = ...</span><br><span class="line"> </span><br><span class="line"><span class="comment">//过滤出值中包含“Xiamen”的元素，contains为String的方法</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> xmus = university filter &#123;kv =&gt; kv._2 contains <span class="string">&quot;Xiamen&quot;</span>&#125;</span><br><span class="line">universityOfXiamen: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = <span class="type">Map</span>(<span class="type">XMU</span> -&gt; <span class="type">Xiamen</span> <span class="type">University</span>, <span class="type">XMUT</span> -&gt; <span class="type">Xiamen</span> <span class="type">University</span> of <span class="type">Technology</span>)</span><br><span class="line"> </span><br><span class="line">scala&gt; <span class="keyword">val</span> l=<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>) filter &#123;_%<span class="number">2</span>==<span class="number">0</span>&#125;</span><br><span class="line"><span class="comment">//使用了占位符语法，过滤能被2整除的元素</span></span><br><span class="line">l: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<h3 id="规约操作"><a href="#规约操作" class="headerlink" title="规约操作"></a>规约操作</h3><ul>
<li>规约操作是对容器元素进行两两运算，将其“规约”为一个值</li>
<li>reduce方法：接受一个二元函数f作为参数，首先将f作用在某两个元素上并返回一个值，然后再将f作用在上一个返回值和容器的下一个元素上，再返回一个值，依此类推，最后容器中的所有值会被规约为一个值</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> list =<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">scala&gt;  list.reduce(_ + _) <span class="comment">//将列表元素累加，使用了占位符语法</span></span><br><span class="line">res16: <span class="type">Int</span> = <span class="number">15</span></span><br><span class="line">scala&gt;  list.reduce(_ * _) <span class="comment">//将列表元素连乘</span></span><br><span class="line">res17: <span class="type">Int</span> = <span class="number">120</span></span><br><span class="line">scala&gt; list map (_.toString) reduce ((x,y)=&gt;<span class="string">s&quot;f(<span class="subst">$x</span>,<span class="subst">$y</span>)&quot;</span>)</span><br><span class="line">res5: <span class="type">String</span> = f(f(f(f(<span class="number">1</span>,<span class="number">2</span>),<span class="number">3</span>),<span class="number">4</span>),<span class="number">5</span>) <span class="comment">//f表示传入reduce的二元函数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>reduceLeft和reduceRight：前者从左到右进行遍历，后者从右到左进行遍历</li>
</ul>
<p><img data-src="scala-learning/image-20191216103846484.png" alt="image-20191216103846484"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">scala&gt; list reduceLeft &#123;_-_&#125;</span><br><span class="line">res24: <span class="type">Int</span> = <span class="number">-13</span></span><br><span class="line">scala&gt; list reduceRight &#123;_-_&#125;</span><br><span class="line">res25: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line">scala&gt; <span class="keyword">val</span> s = list map (_.toString)  <span class="comment">//将整型列表转换成字符串列表</span></span><br><span class="line">s: <span class="type">List</span>[<span class="type">String</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">scala&gt; s reduceLeft &#123;(accu,x)=&gt;<span class="string">s&quot;(<span class="subst">$accu</span>-<span class="subst">$x</span>)&quot;</span>&#125;</span><br><span class="line">res28: <span class="type">String</span> = ((((<span class="number">1</span><span class="number">-2</span>)<span class="number">-3</span>)<span class="number">-4</span>)<span class="number">-5</span>)<span class="comment">//list reduceLeft&#123;_-_&#125;的计算过程</span></span><br><span class="line">scala&gt; s reduceRight &#123;(x,accu)=&gt;<span class="string">s&quot;(<span class="subst">$x</span>-<span class="subst">$accu</span>)&quot;</span>&#125;</span><br><span class="line">res30: <span class="type">String</span> = (<span class="number">1</span>-(<span class="number">2</span>-(<span class="number">3</span>-(<span class="number">4</span><span class="number">-5</span>))))<span class="comment">//list reduceRight&#123;_-_&#125;的计算过程</span></span><br></pre></td></tr></table></figure>

<ul>
<li>fold方法：一个双参数列表的函数，从提供的初始值开始规约。第一个参数列表接受一个规约的初始值，第二个参数列表接受与reduce中一样的二元函数参数</li>
<li>foldLeft和foldRight：前者从左到右进行遍历，后者从右到左进行遍历</li>
</ul>
<p><img data-src="scala-learning/image-20191216103918550.png" alt="image-20191216103918550"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> list =<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">scala&gt; list.fold(<span class="number">10</span>)(_*_)</span><br><span class="line">res32: <span class="type">Int</span> = <span class="number">1200</span></span><br><span class="line">scala&gt; (list fold <span class="number">10</span>)(_*_) <span class="comment">//fold的中缀调用写法</span></span><br><span class="line">res33: <span class="type">Int</span> = <span class="number">1200</span></span><br><span class="line">scala&gt; (list foldLeft <span class="number">10</span>)(_-_)<span class="comment">//计算顺序(((((10-1)-2)-3)-4)-5)</span></span><br><span class="line">res34: <span class="type">Int</span> = <span class="number">-5</span> </span><br><span class="line">scala&gt; (list foldRight <span class="number">10</span>)(_-_) <span class="comment">//计算顺序(1-(2-(3-(4-(5-10)))))</span></span><br><span class="line">res35: <span class="type">Int</span> = <span class="number">-7</span></span><br></pre></td></tr></table></figure>

<h2 id="函数式编程实例WordCount"><a href="#函数式编程实例WordCount" class="headerlink" title="函数式编程实例WordCount"></a>函数式编程实例WordCount</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.<span class="type">File</span></span><br><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"><span class="keyword">import</span> collection.mutable.<span class="type">Map</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> dirfile=<span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;testfiles&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> files  = dirfile.listFiles</span><br><span class="line">        <span class="keyword">val</span> results = <span class="type">Map</span>.empty[<span class="type">String</span>,<span class="type">Int</span>]</span><br><span class="line">        <span class="keyword">for</span>(file &lt;-files) &#123;</span><br><span class="line">            <span class="keyword">val</span> data= <span class="type">Source</span>.fromFile(file)</span><br><span class="line">            <span class="keyword">val</span> strs =data.getLines.flatMap&#123;s =&gt;s.split(<span class="string">&quot; &quot;</span>)&#125;</span><br><span class="line">            strs foreach &#123; word =&gt;</span><br><span class="line">                <span class="keyword">if</span> (results.contains(word))</span><br><span class="line">                results(word)+=<span class="number">1</span> <span class="keyword">else</span>  results(word)=<span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        results foreach&#123;<span class="keyword">case</span> (k,v) =&gt; println(<span class="string">s&quot;<span class="subst">$k</span>:<span class="subst">$v</span>&quot;</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>行1-3：导入需要的类；<br>行6：建立一个File对象，这里假设当前文件夹下有一个testfiles文件夹，且里面包含若干文本文件；<br>行7：调用File对象的listFiles方法，得到其下所有文件对象构成的数组，files的类型为Array[java.io.File]；<br>行8：建立一个可变的空的映射（Map）对象results，保存统计结果。映射中的条目都是一个(key,value)键值对，其中，key是单词，value是单词出现的次数；<br>行9：通过for循环对文件对象进行循环，分别处理各个文件；<br>行10：从File对象建立Source对象（参见1.2节介绍），方便文件的读取；<br>行11：getLines方法返回文件各行构成的迭代器对象，类型为Iterator[String]，flatMap进一步将每一行字符串拆分成单词，再返回所有这些单词构成的新字符串迭代器；<br>行12-15：对上述的字符串迭代器进行遍历，在匿名函数中，对于当前遍历到的某个单词，如果这个单词以前已经统计过，就把映射results中以该单词为key的映射条目的value增加1。如果以前没有被统计过，则为这个单词新创建一个映射条目，只需要直接对相应的key进行赋值，就实现了添加新的映射条目；<br>行17：对Map对象results进行遍历，输出统计结果。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>飞木鱼
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://liufengyu.cn/posts/scala-learning.html" title="Scala学习指南">https://liufengyu.cn/posts/scala-learning.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/scala/" rel="tag"><i class="fa fa-tag"></i> Scala</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/trash-classification.html" rel="prev" title="【深度学习】手把手教你用卷积神经网络做垃圾分类">
      <i class="fa fa-chevron-left"></i> 【深度学习】手把手教你用卷积神经网络做垃圾分类
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/spark-learning-1.html" rel="next" title="Spark的设计与运行原理">
      Spark的设计与运行原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Scala%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">Scala简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Scala%E5%AE%89%E8%A3%85"><span class="nav-number">2.</span> <span class="nav-text">Scala安装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK%E5%AE%89%E8%A3%85"><span class="nav-number">2.1.</span> <span class="nav-text">JDK安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD"><span class="nav-number">2.1.1.</span> <span class="nav-text">下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">2.1.2.</span> <span class="nav-text">安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E6%B2%A1%E6%9C%89JRE"><span class="nav-number">2.1.3.</span> <span class="nav-text">JDK没有JRE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scala%E5%AE%89%E8%A3%85-1"><span class="nav-number">2.2.</span> <span class="nav-text">Scala安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E8%BD%BD-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">下载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85-1"><span class="nav-number">2.2.2.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#win"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">win</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">linux</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Scala%E5%9F%BA%E7%A1%80"><span class="nav-number">3.</span> <span class="nav-text">Scala基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F"><span class="nav-number">3.1.</span> <span class="nav-text">基础数据类型和变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.1.</span> <span class="nav-text">基础数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">3.1.2.</span> <span class="nav-text">字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.1.3.</span> <span class="nav-text">操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%8C%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">富包装类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">3.1.4.</span> <span class="nav-text">变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">3.2.</span> <span class="nav-text">输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.2.1.</span> <span class="nav-text">控制台输入输出语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="nav-number">3.2.2.</span> <span class="nav-text">读写文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">写入文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">读取文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.</span> <span class="nav-text">控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">3.3.1.</span> <span class="nav-text">if条件表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.3.2.</span> <span class="nav-text">while循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.3.3.</span> <span class="nav-text">for循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">3.3.4.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="nav-number">3.3.5.</span> <span class="nav-text">对循环的控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%EF%BC%88Array%EF%BC%89"><span class="nav-number">3.4.1.</span> <span class="nav-text">数组（Array）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%BB%84%EF%BC%88Tuple%EF%BC%89"><span class="nav-number">3.4.2.</span> <span class="nav-text">元组（Tuple）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%EF%BC%88Collection%EF%BC%89"><span class="nav-number">3.4.3.</span> <span class="nav-text">容器（Collection）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%EF%BC%88Sequence%EF%BC%89"><span class="nav-number">3.4.4.</span> <span class="nav-text">序列（Sequence）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8-List"><span class="nav-number">3.4.4.1.</span> <span class="nav-text">列表(List)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E9%87%8F-Vector"><span class="nav-number">3.4.4.2.</span> <span class="nav-text">向量(Vector)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Range"><span class="nav-number">3.4.4.3.</span> <span class="nav-text">Range</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89"><span class="nav-number">3.4.5.</span> <span class="nav-text">集合（Set）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%EF%BC%88Map%EF%BC%89"><span class="nav-number">3.4.6.</span> <span class="nav-text">映射（Map）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E7%9A%84%E6%98%A0%E5%B0%84"><span class="nav-number">3.4.6.1.</span> <span class="nav-text">可变的映射</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88Iterator%EF%BC%89"><span class="nav-number">3.4.7.</span> <span class="nav-text">迭代器（Iterator）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">4.</span> <span class="nav-text">面向对象编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">4.1.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.1.</span> <span class="nav-text">类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">4.1.2.</span> <span class="nav-text">类成员的可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="nav-number">4.1.3.</span> <span class="nav-text">方法的定义方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-number">4.1.4.</span> <span class="nav-text">构造器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.2.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.2.1.</span> <span class="nav-text">单例对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AD%A4%E7%AB%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">伴生对象和孤立对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.2.</span> <span class="nav-text">apply方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#update%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.3.</span> <span class="nav-text">update方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unapply%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.4.</span> <span class="nav-text">unapply方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">4.3.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">4.3.1.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%B1%BB"><span class="nav-number">4.3.2.</span> <span class="nav-text">扩展类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scala%E7%9A%84%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.3.</span> <span class="nav-text">Scala的类层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Option%E7%B1%BB"><span class="nav-number">4.3.4.</span> <span class="nav-text">Option类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E8%B4%A8"><span class="nav-number">4.4.</span> <span class="nav-text">特质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E8%B4%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">4.4.1.</span> <span class="nav-text">特质概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E8%B4%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.4.2.</span> <span class="nav-text">特质的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%8A%E7%89%B9%E8%B4%A8%E6%B7%B7%E5%85%A5%E7%B1%BB%E4%B8%AD"><span class="nav-number">4.4.3.</span> <span class="nav-text">把特质混入类中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">4.5.</span> <span class="nav-text">模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#match%E8%AF%AD%E5%8F%A5"><span class="nav-number">4.5.1.</span> <span class="nav-text">match语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#case%E7%B1%BB"><span class="nav-number">4.5.2.</span> <span class="nav-text">case类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">4.6.</span> <span class="nav-text">包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">4.6.1.</span> <span class="nav-text">包的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%8C%85%E6%88%90%E5%91%98"><span class="nav-number">4.6.2.</span> <span class="nav-text">引用包成员</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">5.</span> <span class="nav-text">函数式编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">5.1.</span> <span class="nav-text">函数定义与使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E5%AE%B9%E5%99%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.</span> <span class="nav-text">针对容器的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.1.</span> <span class="nav-text">遍历操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.2.</span> <span class="nav-text">映射操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.3.</span> <span class="nav-text">过滤操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%84%E7%BA%A6%E6%93%8D%E4%BD%9C"><span class="nav-number">5.3.4.</span> <span class="nav-text">规约操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%AE%9E%E4%BE%8BWordCount"><span class="nav-number">5.4.</span> <span class="nav-text">函数式编程实例WordCount</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="飞木鱼"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">飞木鱼</p>
  <div class="site-description" itemprop="description">整理一些值得留意的文章</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Z3Zm1pYW8=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fwfmiao"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmxpdS1mZW5neXVAb3V0bG9vay5jb20=" title="E-Mail → mailto:liu-fengyu@outlook.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==" title="https:&#x2F;&#x2F;github.com&#x2F;">Github</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3d3LmJpbGliaWxpLmNvbS8=" title="https:&#x2F;&#x2F;wwww.bilibili.com&#x2F;">Bilibili</span>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">飞木鱼</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">92k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:24</span>
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://lfyfzy.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "https://liufengyu.cn/posts/scala-learning.html";
    this.page.identifier = "/posts/scala-learning.html";
    this.page.title = "Scala学习指南";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://lfyfzy.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

    </div>
</body>
</html>
